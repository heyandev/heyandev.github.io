
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>iOS开发ARC内存管理技术要点 - heyandev github Blog</title>
  <meta name="author" content="heyan">

  
  <meta name="description" content="iOS开发ARC内存管理技术要点 本文来源于我个人的ARC学习笔记，旨在通过简明扼要的方式总结出iOS开发中ARC(Automatic Reference Counting，自动引用计数)内存管理技术的要点，所以不会涉及全部细节。这篇文章不是一篇标准的ARC使用教程， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://heyandev.github.io/blog/2015/02/10/ioskai-fa-arcnei-cun-guan-li-ji-zhu-yao-dian/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="heyandev github Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">heyandev github Blog</a></h1>
  
    <h2>Go your own way.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://www.google.com.hk/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="heyandev.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">iOS开发ARC内存管理技术要点</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-02-10T09:29:18+08:00'><span class='date'><span class='date-month'>Feb</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>9:29 am</span></time>
        
           | <a href="#disqus_thread"
             data-disqus-identifier="http://heyandev.github.io">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><p>iOS开发ARC内存管理技术要点</p>

<p>本文来源于我个人的ARC学习笔记，旨在通过简明扼要的方式总结出iOS开发中ARC(Automatic Reference Counting，自动引用计数)内存管理技术的要点，所以不会涉及全部细节。这篇文章不是一篇标准的ARC使用教程，并假定读者已经对ARC有了一定了解和使用经验。详细的关于ARC的信息请参见苹果的<a href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html">官方文档</a>与网上的其他教程：）</p>

<!--more-->


<p>本文的主要内容：</p>

<p>ARC的本质
ARC的开启与关闭
ARC的修饰符
ARC与Block
ARC与Toll-Free Bridging
ARC的本质</p>

<p>ARC是编译器（时）特性，而不是运行时特性，更不是垃圾回收器(GC)。</p>

<p>Automatic Reference Counting (ARC) is a compiler-level feature that simplifies the process of managing object lifetimes (memory management) in Cocoa applications.</p>

<p>ARC只是相对于MRC（Manual Reference Counting或称为非ARC，下文中我们会一直使用MRC来指代非ARC的管理方式）的一次改进，但它和之前的技术本质上没有区别。具体信息可以参考<a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html">ARC编译器官方文档</a>。</p>

<p>ARC的开启与关闭</p>

<p>不同于XCode4可以在创建工程时选择关闭ARC，XCode5在创建的工程是默认开启ARC，没有可以关闭ARC的选项。</p>

<p>如果需要对特定文件开启或关闭ARC，可以在工程选项中选择Targets -> Compile Phases -> Compile Sources，在里面找到对应文件，添加flag:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>打开ARC：-fobjc-arc
</span><span class='line'>关闭ARC：-fno-objc-arc</span></code></pre></td></tr></table></div></figure>


<p>ARC的修饰符</p>

<p>ARC主要提供了4种修饰符，他们分别是:<strong>strong,</strong>weak,<strong>autoreleasing,</strong>unsafe_unretained。</p>

<p>__strong
表示引用为强引用。对应在定义property时的&#8221;strong&#8221;。所有对象只有当没有任何一个强引用指向时，才会被释放。</p>

<p>注意：如果在声明引用时不加修饰符，那么引用将默认是强引用。当需要释放强引用指向的对象时，需要将强引用置nil。</p>

<p><strong>weak
表示引用为弱引用。对应在定义property时用的&#8221;weak&#8221;。弱引用不会影响对象的释放，即只要对象没有任何强引用指向，即使有100个弱引用对象指向也没用，该对象依然会被释放。不过好在，对象在被释放的同时，指向它的弱引用会自动被置nil，这个技术叫zeroing weak pointer。这样有效得防止无效指针、野指针的产生。</strong>weak一般用在delegate关系中防止循环引用或者用来修饰指向由Interface Builder编辑与生成的UI控件。</p>

<p>__autoreleasing
表示在autorelease pool中自动释放对象的引用，和MRC时代autorelease的用法相同。定义property时不能使用这个修饰符，任何一个对象的property都不应该是autorelease型的。</p>

<p>一个常见的误解是，在ARC中没有autorelease，因为这样一个“自动释放”看起来好像有点多余。这个误解可能源自于将ARC的“自动”和autorelease“自动”的混淆。其实你只要看一下每个iOS App的main.m文件就能知道，autorelease不仅好好的存在着，并且变得更fashion了：不需要再手工被创建，也不需要再显式得调用[drain]方法释放内存池。</p>

<p>以下两行代码的意义是相同的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSString *str = [[[NSString alloc] initWithFormat:@"hehe"] autorelease]; // MRC
</span><span class='line'>NSString *__autoreleasing str = [[NSString alloc] initWithFormat:@"hehe"]; // ARC</span></code></pre></td></tr></table></div></figure>


<p> 这里关于autoreleasepool就不做展开了，详细地信息可以参考官方文档或者其他文章。</p>

<p>__autoreleasing在ARC中主要用在参数传递返回值（out-parameters）和引用传递参数（pass-by-reference）的情况下。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>__autoreleasing is used to denote arguments that are passed by reference (id *) and are autoreleased on return.</span></code></pre></td></tr></table></div></figure>


<p>比如常用的NSError的使用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSError *__autoreleasing error; 
</span><span class='line'>if (![data writeToFile:filename options:NSDataWritingAtomic error:&error]) 
</span><span class='line'>{ 
</span><span class='line'>　　NSLog(, error); 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>（在上面的writeToFile方法中error参数的类型为(NSError <em>__autoreleasing </em>)）</p>

<p>注意，如果你的error定义为了strong型，那么，编译器会帮你隐式地做如下事情，保证最终传入函数的参数依然是个__autoreleasing类型的引用。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSError *error; 
</span><span class='line'>NSError *__autoreleasing tempError = error; // 编译器添加 
</span><span class='line'>if (![data writeToFile:filename options:NSDataWritingAtomic error:&tempError]) 
</span><span class='line'>{ 
</span><span class='line'>　　error = tempError; // 编译器添加 
</span><span class='line'>　　NSLog(@"Error: %@", error); 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>所以为了提高效率，避免这种情况，我们一般在定义error的时候将其（老老实实地=。=）声明为__autoreleasing类型的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSError *__autoreleasing error;</span></code></pre></td></tr></table></div></figure>


<p>在这里，加上__autoreleasing之后，相当于在MRC中对返回值error做了如下事情：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>*error = [[[NSError alloc] init] autorelease];</span></code></pre></td></tr></table></div></figure>


<p><em>error指向的对象在创建出来后，被放入到了autoreleasing pool中，等待使用结束后的自动释放，函数外error的使用者并不需要关心</em>error指向对象的释放。</p>

<p>另外一点，在ARC中，所有这种指针的指针 （NSError **）的函数参数如果不加修饰符，编译器会默认将他们认定为__autoreleasing类型。</p>

<p>比如下面的两段代码是等同的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSString *)doSomething:(NSNumber **)value
</span><span class='line'>{
</span><span class='line'>        // do something  
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (NSString *)doSomething:(NSNumber * __autoreleasing *)value
</span><span class='line'>{
</span><span class='line'>        // do something  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>除非你显式得给value声明了<strong>strong，否则value默认就是</strong>autoreleasing的。</p>

<p>最后一点，某些类的方法会隐式地使用自己的autorelease pool，在这种时候使用__autoreleasing类型要特别小心。</p>

<p>比如NSDictionary的[enumerateKeysAndObjectsUsingBlock]方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error
</span><span class='line'>{
</span><span class='line'>    [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop){
</span><span class='line'> 
</span><span class='line'>          // do stuff  
</span><span class='line'>          if (there is some error && error != nil)
</span><span class='line'>          {
</span><span class='line'>                *error = [NSError errorWithDomain:@"MyError" ?code:1 userInfo:nil];
</span><span class='line'>          }
</span><span class='line'>
</span><span class='line'>    }];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>会隐式地创建一个autorelease pool，上面代码实际类似于：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error
</span><span class='line'>{
</span><span class='line'>    [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop){
</span><span class='line'> 
</span><span class='line'>          @autoreleasepool  // 被隐式创建
</span><span class='line'>　　　　　　{
</span><span class='line'>              if (there is some error && error != nil)
</span><span class='line'>              {
</span><span class='line'>                    *error = [NSError errorWithDomain:@"MyError" ?code:1 userInfo:nil];
</span><span class='line'>              }
</span><span class='line'>          }
</span><span class='line'>    }];
</span><span class='line'> 
</span><span class='line'>    // *error 在这里已经被dict的做枚举遍历时创建的autorelease pool释放掉了 ：(  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>为了能够正常的使用*error，我们需要一个strong型的临时引用，在dict的枚举Block中是用这个临时引用，保证引用指向的对象不会在出了dict的枚举Block后被释放，正确的方式如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error
</span><span class='line'>{
</span><span class='line'>　　__block NSError* tempError; // 加__block保证可以在Block内被修改  
</span><span class='line'>　　[dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop)
</span><span class='line'>　　{ 
</span><span class='line'>　　　　if (there is some error) 
</span><span class='line'>　　　　{ 
</span><span class='line'>　　　　　　*tempError = [NSError errorWithDomain:@"MyError" ?code:1 userInfo:nil]; 
</span><span class='line'>　　　　}  
</span><span class='line'> 
</span><span class='line'>　　}] 
</span><span class='line'> 
</span><span class='line'>　　if (error != nil) 
</span><span class='line'>　　{ 
</span><span class='line'>　　　　*error = tempError; 
</span><span class='line'>　　} 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>__unsafe_unretained
ARC是在iOS 5引入的，而这个修饰符主要是为了在ARC刚发布时兼容iOS 4以及版本更低的设备，因为这些版本的设备没有weak pointer system，简单的理解这个系统就是我们上面讲weak时提到的，能够在weak引用指向对象被释放后，把引用值自动设为nil的系统。这个修饰符在定义property时对应的是&#8221;unsafe_unretained&#8221;，实际可以将它理解为MRC时代的assign：纯粹只是将引用指向对象，没有任何额外的操作，在指向对象被释放时依然原原本本地指向原来被释放的对象（所在的内存区域）。所以非常不安全。</p>

<p>现在可以完全忽略掉这个修饰符了，因为iOS 4早已退出历史舞台很多年。</p>

<p>*使用修饰符的正确姿势（方式=。=）
这可能是很多人都不知道的一个问题，包括之前的我，但却是一个特别要注意的问题。</p>

<p>苹果的文档中明确地写道：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>You should decorate variables correctly. When using qualifiers in an object variable declaration,
</span><span class='line'>
</span><span class='line'>the correct format is:
</span><span class='line'>
</span><span class='line'>ClassName * qualifier variableName;</span></code></pre></td></tr></table></div></figure>


<p>按照这个说明，要定义一个weak型的NSString引用，它的写法应该是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSString * __weak str = @"hehe"; // 正确！
</span><span class='line'>而不应该是：
</span><span class='line'>
</span><span class='line'>__weak NSString *str = @"hehe";  // 错误！</span></code></pre></td></tr></table></div></figure>


<p>我相信很多人都和我一样，从开始用ARC就一直用上面那种错误的写法。</p>

<p>那这里就有疑问了，既然文档说是错误的，为啥编译器不报错呢？文档又解释道：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Other variants are technically incorrect but are “forgiven” by the compiler. To understand the issue, seehttp://cdecl.org/.</span></code></pre></td></tr></table></div></figure>


<p>好吧，看来是苹果爸爸（=.=）考虑到很多人会用错，所以在编译器这边贴心地帮我们忽略并处理掉了这个错误，虽然不报错，但是我们还是应该按照正确的方式去使用这些修饰符，如果你以前也常常用错误的写法，那看到这里记得以后不要这么写了，哪天编译器怒了，再不支持错误的写法，就要郁闷了。</p>

<p>栈中指针默认值为nil
无论是被strong，weak还是autoreleasing修饰，声明在栈中的指针默认值都会是nil。所有这类型的指针不用再初始化的时候置nil了。虽然好习惯是最重要的，但是这个特性更加降低了“野指针”出现的可能性。</p>

<p>在ARC中，以下代码会输出null而不是crash:)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)myMethod 
</span><span class='line'>{
</span><span class='line'>    NSString *name;
</span><span class='line'>    NSLog(@"name: %@", name);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>ARC与Block</p>

<p>在MRC时代，Block会隐式地对进入其作用域内的对象（或者说被Block捕获的指针指向的对象）加retain，来确保Block使用到该对象时，能够正确的访问。</p>

<p>这件事情在下面代码展示的情况中要更加额外小心。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MyViewController *myController = [[MyViewController alloc] init…];
</span><span class='line'> 
</span><span class='line'>// 隐式地调用[myController retain];造成循环引用
</span><span class='line'>myController.completionHandler =  ^(NSInteger result) {
</span><span class='line'>   [myController dismissViewControllerAnimated:YES completion:nil];
</span><span class='line'>};
</span><span class='line'> 
</span><span class='line'>[self presentViewController:myController animated:YES completion:^{
</span><span class='line'>   [myController release]; // 注意，这里调用[myController release];是在MRC中的一个常规写法，并不能解决上面循环引用的问题
</span><span class='line'>}];</span></code></pre></td></tr></table></div></figure>


<p>在这段代码中，myController的completionHandler调用了myController的方法[dismissViewController&hellip;]，这时completionHandler会对myController做retain操作。而我们知道，myController对completionHandler也至少有一个retain（一般准确讲是copy），这时就出现了在内存管理中最糟糕的情况：循环引用！简单点说就是：myController retain了completionHandler，而completionHandler也retain了myController。循环引用导致了myController和completionHandler最终都不能被释放。我们在delegate关系中，对delegate指针用weak就是为了避免这种问题。</p>

<p>不过好在，编译器会及时地给我们一个警告，提醒我们可能会发生这类型的问题：</p>

<p>对这种情况，我们一般用如下方法解决：给要进入Block的指针加一个__block修饰符。</p>

<p>这个__block在MRC时代有两个作用：</p>

<p>说明变量可改
说明指针指向的对象不做这个隐式的retain操作
一个变量如果不加<strong>block，是不能在Block里面修改的，不过这里有一个例外：static的变量和全局变量不需要加</strong>block就可以在Block中修改。</p>

<p>使用这种方法，我们对代码做出修改，解决了循环引用的问题：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MyViewController * __block myController = [[MyViewController alloc] init…];
</span><span class='line'>// ...
</span><span class='line'>myController.completionHandler =  ^(NSInteger result) {
</span><span class='line'>    [myController dismissViewControllerAnimated:YES completion:nil];
</span><span class='line'>};
</span><span class='line'>//之后正常的release或者retain</span></code></pre></td></tr></table></div></figure>


<p>在ARC引入后，没有了retain和release等操作，情况也发生了改变：在任何情况下，<strong>block修饰符的作用只有上面的第一条：说明变量可改。即使加上了</strong>block修饰符，一个被block捕获的强引用也依然是一个强引用。这样在ARC下，如果我们还按照MRC下的写法，completionHandler对myController有一个强引用，而myController对completionHandler有一个强引用，这依然是循环引用，没有解决问题：（</p>

<p>于是我们还需要对原代码做修改。简单的情况我们可以这样写：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>__block MyViewController * myController = [[MyViewController alloc] init…];
</span><span class='line'>// ...
</span><span class='line'>myController.completionHandler =  ^(NSInteger result) {
</span><span class='line'>    [myController dismissViewControllerAnimated:YES completion:nil];
</span><span class='line'>    myController = nil;  // 注意这里，保证了block结束myController强引用的解除
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>在completionHandler之后将myController指针置nil，保证了completionHandler对myController强引用的解除，不过也同时解除了myController对myController对象的强引用。这种方法过于简单粗暴了，在大多数情况下，我们有更好的方法。</p>

<p>这个更好的方法就是使用weak。（或者为了考虑iOS4的兼容性用unsafe_unretained，具体用法和weak相同，考虑到现在iOS4设备可能已经绝迹了，这里就不讲这个方法了）（关于这个方法的本质我们后面会谈到）</p>

<p>为了保证completionHandler这个Block对myController没有强引用，我们可以定义一个临时的弱引用weakMyViewController来指向原myController的对象，并把这个弱引用传入到Block内，这样就保证了Block对myController持有的是一个弱引用，而不是一个强引用。如此，我们继续修改代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MyViewController *myController = [[MyViewController alloc] init…];
</span><span class='line'>// ...
</span><span class='line'>MyViewController * __weak weakMyViewController = myController;
</span><span class='line'>myController.completionHandler =  ^(NSInteger result) {
</span><span class='line'>    [weakMyViewController dismissViewControllerAnimated:YES completion:nil];
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>这样循环引用的问题就解决了，但是却不幸地引入了一个新的问题：由于传入completionHandler的是一个弱引用，那么当myController指向的对象在completionHandler被调用前释放，那么completionHandler就不能正常的运作了。在一般的单线程环境中，这种问题出现的可能性不大，但是到了多线程环境，就很不好说了，所以我们需要继续完善这个方法。</p>

<p>为了保证在Block内能够访问到正确的myController，我们在block内新定义一个强引用strongMyController来指向weakMyController指向的对象，这样多了一个强引用，就能保证这个myController对象不会在completionHandler被调用前释放掉了。于是，我们对代码再次做出修改：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MyViewController *myController = [[MyViewController alloc] init…];
</span><span class='line'>// ...
</span><span class='line'>MyViewController * __weak weakMyController = myController;
</span><span class='line'>myController.completionHandler =  ^(NSInteger result) {
</span><span class='line'>    MyViewController *strongMyController = weakMyController;
</span><span class='line'> 
</span><span class='line'>　　if (strongMyController) {
</span><span class='line'>        // ...
</span><span class='line'>        [strongMyController dismissViewControllerAnimated:YES completion:nil];
</span><span class='line'>        // ...
</span><span class='line'>    }
</span><span class='line'>    else {
</span><span class='line'>        // Probably nothing...
</span><span class='line'>    }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>到此，一个完善的解决方案就完成了：）</p>

<p>官方文档对这个问题的说明到这里就结束了，但是可能很多朋友会有疑问，不是说不希望Block对原myController对象增加强引用么，这里为啥堂而皇之地在Block内新定义了一个强引用，这个强引用不会造成循环引用么？理解这个问题的关键在于理解被Block捕获的引用和在Block内定义的引用的区别。为了搞得明白这个问题，这里需要了解一些Block的实现原理，但由于篇幅的缘故，本文在这里就不展开了，详细的内容可以参考其他的文章。</p>

<p>这里假设大家已经对Block的实现原理有所了解了。我们就直入主题了！注意前方高能（=。=）</p>

<p>为了更清楚地说明问题，这里用一个简单的程序举例。比如我们有如下程序：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt; stdio.h&gt;
</span><span class='line'> 
</span><span class='line'>int main()
</span><span class='line'>{
</span><span class='line'>    int b = 10;
</span><span class='line'>     
</span><span class='line'>    int *a = &b;
</span><span class='line'>     
</span><span class='line'>    void (^blockFunc)() = ^(){
</span><span class='line'>     
</span><span class='line'>        int *c = a;
</span><span class='line'> 
</span><span class='line'>    };
</span><span class='line'>     
</span><span class='line'>    blockFunc();
</span><span class='line'>     
</span><span class='line'>    return 1;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>程序中，同为int型的指针，a是被Block捕获的变量，而c是在Block内定义的变量。我们用clang -rewrite-objc处理后，可以看到如下代码：</p>

<p>原main函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int main()
</span><span class='line'>{
</span><span class='line'>    int b = 10;
</span><span class='line'> 
</span><span class='line'>    int *a = &b;
</span><span class='line'> 
</span><span class='line'>    void (*blockFunc)() = (void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, a);
</span><span class='line'> 
</span><span class='line'>    ((void (*)(__block_impl *))((__block_impl *)blockFunc)-&gt;FuncPtr)((__block_impl *)blockFunc);
</span><span class='line'> 
</span><span class='line'>    return 1;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Block的结构：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct __main_block_impl_0 {
</span><span class='line'>  struct __block_impl impl;
</span><span class='line'>  struct __main_block_desc_0* Desc;
</span><span class='line'>   
</span><span class='line'>  int *a; // 被捕获的引用 a 出现在了block的结构体里面
</span><span class='line'>   
</span><span class='line'>  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_a, int flags=0) : a(_a) {
</span><span class='line'>    impl.isa = &_NSConcreteStackBlock;
</span><span class='line'>    impl.Flags = flags;
</span><span class='line'>    impl.FuncPtr = fp;
</span><span class='line'>    Desc = desc;
</span><span class='line'>  }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>实际执行的函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
</span><span class='line'>  int *a = __cself-&gt;a; // bound by copy
</span><span class='line'> 
</span><span class='line'> 
</span><span class='line'>        int *c = a; // 在block中声明的引用 c 在函数中声明，存在于函数栈上
</span><span class='line'> 
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>我们可以清楚得看到，a和c存在的位置完全不同，如果Block存在于堆上（在ARC下Block默认在堆上），那么a作为Block结构体的一个成员，也自然会存在于堆上，而c无论如何，永远位于Block内实际执行代码的函数栈内。这也导致了两个变量生命周期的完全不同：c在Block的函数运行完毕，即会被释放，而a呢，只有在Block被从堆上释放的时候才会释放。</p>

<p>回到我们的MyViewController的例子中，同上理，如果我们直接让Block捕获我们的myController引用，那么这个引用会被复制后（引用类型也会被复制）作为Block的成员变量存在于其所在的堆空间中，也就是为Block增加了一个指向myController对象的强引用，这就是造成循环引用的本质原因。对于MyViewController的例子，Block的结构体可以理解是这个样子：（准确的结构体肯定和以下这个有区别，但也肯定是如下这种形式：）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct __main_block_impl_0 {
</span><span class='line'>  struct __block_impl impl;
</span><span class='line'>  struct __main_block_desc_0* Desc;
</span><span class='line'>   
</span><span class='line'>  MyViewController * __strong myController;  // 被捕获的强引用myController
</span><span class='line'>   
</span><span class='line'>  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_a, int flags=0) : a(_a) {
</span><span class='line'>    impl.isa = &_NSConcreteStackBlock;
</span><span class='line'>    impl.Flags = flags;
</span><span class='line'>    impl.FuncPtr = fp;
</span><span class='line'>    Desc = desc;
</span><span class='line'>  }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>而反观我们给Block传入一个弱引用weakMyController，这时我们Block的结构：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct __main_block_impl_0 {
</span><span class='line'>  struct __block_impl impl;
</span><span class='line'>  struct __main_block_desc_0* Desc;
</span><span class='line'>   
</span><span class='line'>  MyViewController * __weak weakMyController;  // 被捕获的弱引用weakMyController
</span><span class='line'>   
</span><span class='line'>  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_a, int flags=0) : a(_a) {
</span><span class='line'>    impl.isa = &_NSConcreteStackBlock;
</span><span class='line'>    impl.Flags = flags;
</span><span class='line'>    impl.FuncPtr = fp;
</span><span class='line'>    Desc = desc;
</span><span class='line'>  }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>再看在Block内声明的强引用strongMyController，它虽然是强引用，但存在于函数栈中，在函数执行期间，它一直存在，所以myController对象也一直存在，但是当函数执行完毕，strongMyController即被销毁，于是它对myController对象的强引用也被解除，这时Block对myController对象就不存在强引用关系了！加入了strongMyController的函数大体会是这个样子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
</span><span class='line'> 
</span><span class='line'>  MyViewController * __strong strongMyController = __cself-&gt;weakMyController; 
</span><span class='line'> 
</span><span class='line'>    // ....
</span><span class='line'> 
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>综上所述，在ARC下（在MRC下会略有不同），Block捕获的引用和Block内声明的引用无论是存在空间与生命周期都是截然不同的，也正是这种不同，造成了我们对他们使用方式的区别。</p>

<p>以上就解释了之前提到的所有问题，希望大家能看明白：）</p>

<p>好的，最后再提一点，在ARC中，对Block捕获对象的内存管理已经简化了很多，由于没有了retain和release等操作，实际只需要考虑循环引用的问题就行了。比如下面这种，是没有内存泄露的问题的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>TestObject *aObject = [[TestObject alloc] init];
</span><span class='line'>     
</span><span class='line'>aObject.name = @"hehe";
</span><span class='line'> 
</span><span class='line'>self.aBlock = ^(){
</span><span class='line'>     
</span><span class='line'>    NSLog(@"aObject's name = %@",aObject.name);
</span><span class='line'>         
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>我们上面提到的解决方案，只是针对Block产生循环引用的问题，而不是说所有的Block捕获引用都要这么处理，一定要注意！</p>

<p>ARC与Toll-Free Bridging</p>

<p>There are a number of data types in the Core Foundation framework and the Foundation framework that can be used interchangeably. This capability, called toll-free bridging, means that you can use the same data type as the parameter to a Core Foundation function call or as the receiver of an Objective-C message.</p>

<p>Toll-Free Briding保证了在程序中，可以方便和谐的使用Core Foundation类型的对象和Objective-C类型的对象。详细的内容可参考官方文档。以下是官方文档中给出的一些例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSLocale *gbNSLocale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_GB"];
</span><span class='line'>CFLocaleRef gbCFLocale = (CFLocaleRef) gbNSLocale;
</span><span class='line'>CFStringRef cfIdentifier = CFLocaleGetIdentifier (gbCFLocale);
</span><span class='line'>NSLog(@"cfIdentifier: %@", (NSString *)cfIdentifier);
</span><span class='line'>// logs: "cfIdentifier: en_GB"
</span><span class='line'>CFRelease((CFLocaleRef) gbNSLocale);
</span><span class='line'>  
</span><span class='line'>CFLocaleRef myCFLocale = CFLocaleCopyCurrent();
</span><span class='line'>NSLocale * myNSLocale = (NSLocale *) myCFLocale;
</span><span class='line'>[myNSLocale autorelease];
</span><span class='line'>NSString *nsIdentifier = [myNSLocale localeIdentifier];
</span><span class='line'>CFShow((CFStringRef) [@"nsIdentifier: " stringByAppendingString:nsIdentifier]);
</span><span class='line'>// logs identifier for current locale</span></code></pre></td></tr></table></div></figure>


<p>在MRC时代，由于Objective-C类型的对象和Core Foundation类型的对象都是相同的release和retain操作规则，所以Toll-Free Bridging的使用比较简单，但是自从ARC加入后，Objective-C类型的对象内存管理规则改变了，而Core Foundation依然是之前的机制，换句话说，Core Foundation不支持ARC。</p>

<p>这个时候就必须要要考虑一个问题了，在做Core Foundation与Objective-C类型转换的时候，用哪一种规则来管理对象的内存。显然，对于同一个对象，我们不能够同时用两种规则来管理，所以这里就必须要确定一件事情：哪些对象用Objective-C（也就是ARC）的规则，哪些对象用Core Foundation的规则（也就是MRC）的规则。或者说要确定对象类型转换了之后，内存管理的ownership的改变。</p>

<p>If you cast between Objective-C and Core Foundation-style objects, you need to tell the compiler about the ownership semantics of the object using either a cast (defined in objc/runtime.h) or a Core Foundation-style macro (defined inNSObject.h)</p>

<p>于是苹果在引入ARC之后对Toll-Free Bridging的操作也加入了对应的方法与修饰符，用来指明用哪种规则管理内存，或者说是内存管理权的归属。</p>

<p>这些方法和修饰符分别是：</p>

<p>__bridge（修饰符）
只是声明类型转变，但是不做内存管理规则的转变。</p>

<p>比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CFStringRef s1 = (__bridge CFStringRef) [[NSString alloc] initWithFormat:@"Hello, %@!", name];</span></code></pre></td></tr></table></div></figure>


<p>只是做了NSString到CFStringRef的转化，但管理规则未变，依然要用Objective-C类型的ARC来管理s1，你不能用CFRelease()去释放s1。</p>

<p>__bridge_retained（修饰符） or CFBridgingRetain（函数）
表示将指针类型转变的同时，将内存管理的责任由原来的Objective-C交给Core Foundation来处理，也就是，将ARC转变为MRC。</p>

<p>比如，还是上面那个例子</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSString *s1 = [[NSString alloc] initWithFormat:@"Hello, %@!", name];
</span><span class='line'>?CFStringRef s2 = (__bridge_retained CFStringRef)s1;
</span><span class='line'>// do something with s2
</span><span class='line'>//...
</span><span class='line'>CFRelease(s2); // 注意要在使用结束后加这个</span></code></pre></td></tr></table></div></figure>


<p>我们在第二行做了转化，这时内存管理规则由ARC变为了MRC，我们需要手动的来管理s2的内存，而对于s1，我们即使将其置为nil，也不能释放内存。</p>

<p>等同的，我们的程序也可以写成：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSString *s1 = [[NSString alloc] initWithFormat:@"Hello, %@!", name];
</span><span class='line'>CFStringRef s2 = (CFStringRef)CFBridgingRetain(s1);
</span><span class='line'>// do something with s2
</span><span class='line'>//...
</span><span class='line'>CFRelease(s2); // 注意要在使用结束后加这个</span></code></pre></td></tr></table></div></figure>


<p><strong>bridge_transfer（修饰符） or CFBridgingRelease（函数）
这个修饰符和函数的功能和上面那个</strong>bridge_retained相反，它表示将管理的责任由Core Foundation转交给Objective-C，即将管理方式由MRC转变为ARC。</p>

<p>比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CFStringRef result = CFURLCreateStringByAddingPercentEscapes(. . .);
</span><span class='line'>NSString *s = (__bridge_transfer NSString *)result;
</span><span class='line'>//or NSString *s = (NSString *)CFBridgingRelease(result);
</span><span class='line'>return s;</span></code></pre></td></tr></table></div></figure>


<p>这里我们将result的管理责任交给了ARC来处理，我们就不需要再显式地将CFRelease()了。</p>

<p>对了，这里你可能会注意到一个细节，和ARC中那个4个主要的修饰符（<strong>strong,</strong>weak,&hellip;）不同，这里修饰符的位置是放在类型前面的，虽然官方文档中没有说明，但看官方的头文件可以知道。小伙伴们，记得别把位置写错哦：）</p>

<p>呼~ 好了，以上就是本篇文章的主要内容。</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">heyan</span></span>

      




<time class='entry-date' datetime='2015-02-10T09:29:18+08:00'><span class='date'><span class='date-month'>Feb</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>9:29 am</span></time>
      


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://heyandev.github.io/blog/2015/02/10/ioskai-fa-arcnei-cun-guan-li-ji-zhu-yao-dian/" data-via="" data-counturl="http://heyandev.github.io/blog/2015/02/10/ioskai-fa-arcnei-cun-guan-li-ji-zhu-yao-dian/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/02/06/25ge-gityong-fa-ji-qiao/" title="Previous Post: 25个Git用法技巧">&laquo; 25个Git用法技巧</a>
      
      
        <a class="basic-alignment right" href="/blog/2015/02/10/clone-your-octopress-to-blog-from-two-places/" title="Next Post: Clone Your Octopress to Blog From Two Places">Clone Your Octopress to Blog From Two Places &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/02/10/clone-your-octopress-to-blog-from-two-places/">Clone Your Octopress to Blog From Two Places</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/02/10/ioskai-fa-arcnei-cun-guan-li-ji-zhu-yao-dian/">iOS开发ARC内存管理技术要点</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/02/06/25ge-gityong-fa-ji-qiao/">25个Git用法技巧</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/29/yong-cocoapodszuo-ioscheng-xu-de-yi-lai-guan-li/">用cocoapods做ios程序的依赖管理</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/29/zai-githubshang-da-jian-octopressbo-ke/">在Github上搭建Octopress博客</a>
      </li>
    
  </ul>
</section>
<section>
<h1>personal csdn blog</h1>
<ul>
        <li>
        <a href="http://blog.csdn.net/u012094456">sven的专栏</a>
        </li>
</ul>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - heyan -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'heyandev';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://heyandev.github.io/blog/2015/02/10/ioskai-fa-arcnei-cun-guan-li-ji-zhu-yao-dian/';
        var disqus_url = 'http://heyandev.github.io/blog/2015/02/10/ioskai-fa-arcnei-cun-guan-li-ji-zhu-yao-dian/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
