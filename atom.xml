<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[heyandev github Blog]]></title>
  <link href="http://heyandev.github.io/atom.xml" rel="self"/>
  <link href="http://heyandev.github.io/"/>
  <updated>2015-02-06T10:41:16+08:00</updated>
  <id>http://heyandev.github.io/</id>
  <author>
    <name><![CDATA[heyan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[25个Git用法技巧]]></title>
    <link href="http://heyandev.github.io/blog/2015/02/06/25ge-gityong-fa-ji-qiao/"/>
    <updated>2015-02-06T09:38:24+08:00</updated>
    <id>http://heyandev.github.io/blog/2015/02/06/25ge-gityong-fa-ji-qiao</id>
    <content type="html"><![CDATA[<p>作为一个很享受git的人，我想要分享从各种社区学到的实用经验，让大家不需要花费过多的功夫就能找到答案。</p>

<!--more-->


<p>基本技巧</p>

<p>1.安装后的第一步</p>

<p>安装git后，第一件事你需要设置你的名字和邮箱，因为每次提交都需要这些信息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git config --global user.name "Some One"
</span><span class='line'>$ git config --global user.email "someone@gmail.com"</span></code></pre></td></tr></table></div></figure>


<p>2.是基于指针的</p>

<p>git上的所有东西都是储存在文件里的，当你创建一次提交时，它会创建一个包含你的提交信息和相关数据（名字，邮箱，日期/时间、上一次提交等等）的文件并连接一个树文件，而这个树文件包含了对象列表或者其他树。这上面的对象或者blob文件就是这次提交的实际内容（你可以认为这也是一个文件，尽管并没有储存在对象里而是储存在树中）。所有的文件都以经过SHA-1计算后的文件名（译者注：经过SHA-1计算后的数，即git中的版本号）储存在上面。</p>

<p>从这里可以看出，分支和标签都是包含一个指向这次提交的sha-1数（版本号）简单的文件，这样使用引用会变得更快和更灵活，创建一个新的分支是就像创建文件一样简单，SHA – 1数（版本号）也会引用你这个分支的提交。当然，如果你使用GIT命令行工具（或者GUI）你将无法接触这些。但真的很简单。</p>

<p>你可能听说过HEAD引用，这是一个指向你当前提交的内容的SHA-1 数（版本号）的指针。如果你正在解决合并冲突，使用HEAD不会对你的特定分支有任何改动只会指向你当前的分支。</p>

<p>所有分支的指针都保存在 .git/refs/heads，HEAD指针保存在.git/HEAD，标签则保存在 .git/refs/tags，有时间就去看看吧。</p>

<p>3.两个母体（Parent），当然！</p>

<p>当我们在日志文件中查看合并提交信息，你会看到两个母体，第一个母体是正在进行的分支，第二个是你要合并的分支。</p>

<p>4.合并冲突</p>

<p>现在，我发现有合并冲突并解决了它，这是一件在我们编辑文件时很正常的事。将 &lt;&lt;&lt;&lt;, ====, >>>> 这些标记移除后，并保存你想要保存的代码。有些时候在代码被直接替代之前，能看到冲突是件挺不错的事。比如在两个冲突的分支变动之前，可以用这样的命令方式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git diff --merge
</span><span class='line'>diff --cc dummy.rb  
</span><span class='line'>index 5175dde,0c65895..4a00477  
</span><span class='line'>--- a/dummy.rb
</span><span class='line'>+++ b/dummy.rb
</span><span class='line'>@@@ -1,5 -1,5 +1,5 @@@
</span><span class='line'>  class MyFoo
</span><span class='line'>    def say
</span><span class='line'>-     puts "Bonjour"
</span><span class='line'> -    puts "Hello world"
</span><span class='line'>++    puts "Annyong Haseyo"
</span><span class='line'>    end
</span><span class='line'>  end
</span><span class='line'>
</span><span class='line'>If the file is binary, diffing files isn’t so easy… What you’ll normally want to do is to try each version of the binary file and decide which one to use (or manually copy portions over in the binary file’s editor). To pull a copy of the file from a particular branch (say you’re merging master and feature132):</span></code></pre></td></tr></table></div></figure>


<p>如果是二进制文件（binary），区别这些文件并不容易。通常你会查看每个二进制文件的版本，再决定使用哪个（或者在二进制文件编辑器中手动复制），并将其推送至特定的分支。（比如你要合并master和feature132）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git checkout master flash/foo.fla # or...
</span><span class='line'>$ git checkout feature132 flash/foo.fla
</span><span class='line'>$ # Then...
</span><span class='line'>$ git add flash/foo.fla
</span><span class='line'>
</span><span class='line'>Another way is to cat the file from git – you can do this to another filename then copy the correct file over (when you’ve decided which it is) to the normal filename:</span></code></pre></td></tr></table></div></figure>


<p>另一个方法就是在git中cat文件，你可以将其命名为另一个文件名，然后将你决定的那个文件改为正确的文件名：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git show master:flash/foo.fla &gt; master-foo.fla
</span><span class='line'>$ git show feature132:flash/foo.fla &gt; feature132-foo.fla
</span><span class='line'>$ # Check out master-foo.fla and feature132-foo.fla
</span><span class='line'>$ # Let's say we decide that feature132's is correct
</span><span class='line'>$ rm flash/foo.fla
</span><span class='line'>$ mv feature132-foo.fla flash/foo.fla
</span><span class='line'>$ rm master-foo.fla
</span><span class='line'>$ git add flash/foo.fla</span></code></pre></td></tr></table></div></figure>


<p>更新：可以使用 “git checkout —ours flash/foo.fla” 和“git checkout —theirs flash/foo.fla” 在不用考虑你需要合并的分支来检查指定版本，就我个人而言，我喜欢更明确的方法，但这也是一个选择…</p>

<p>记住，解决完合并冲突后要添加文件。（我之前就犯过这样的错误）</p>

<p>服务，分支和标注</p>

<p>5.远程服务</p>

<p>Git有一个非常强大的特性，就是可以有多个远程服务端（以及你运行的一个本地仓库）。你不需要总是进行访问，你可以有多个服务端并能从其中一个（合并工作）读取再写入另一个。添加一个远程服务端很简单：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git remote add john git@github.com:johnsomeone/someproject.git
</span><span class='line'>
</span><span class='line'>If you want to see information about your remote servers you can do:</span></code></pre></td></tr></table></div></figure>


<p>如果你想查看远程服务端的信息你可以：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># shows URLs of each remote server
</span><span class='line'>$ git remote -v 
</span><span class='line'>
</span><span class='line'># gives more details about each
</span><span class='line'>$ git remote show name 
</span><span class='line'>
</span><span class='line'>You can always see the differences between a local branch and a remote branch:</span></code></pre></td></tr></table></div></figure>


<p>你总是能看到本地分支和远程分支不同的地方：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git diff master..john/master
</span><span class='line'>
</span><span class='line'>You can also see the changes on HEAD that aren’t on that remote branch:</span></code></pre></td></tr></table></div></figure>


<p>你同样也能看到远程分支上没有的HEAD指针的改动：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git log remote/branch..
</span><span class='line'># Note: no final refspec after ..</span></code></pre></td></tr></table></div></figure>


<p>6.Tagging 标签</p>

<p>在Git中有两种类型的标注：轻量级标注和注释型标注。</p>

<p>记住第二个是Git的指针基础，两者区别很简单，轻量级标注是简单命名提交的指针，你可以将其指向另一个提交。注释型标注是一个有信息和历史并指向标注对象的名字指针，它有着自己的信息，如果需要的话，可以进行GPG标记。</p>

<p>创建两种类型的标签很简单（其中一个命令行有改动）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git tag to-be-tested
</span><span class='line'>$ git tag -a v1.1.0 # Prompts for a tag message</span></code></pre></td></tr></table></div></figure>


<p>7.Creating Branches 创建分支</p>

<p>在git中创建分支是件非常简单的事情（非常快并只需要不到100byte的文件大小）。创建新分支并切换到该分支，通常是下面这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git branch feature132
</span><span class='line'>$ git checkout feature132</span></code></pre></td></tr></table></div></figure>


<p>当然，如果你想切换到该分支，最直接的方式是使用这样一条命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git checkout -b feature132</span></code></pre></td></tr></table></div></figure>


<p>如果你想要重新命名本地分支，也很简单：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git checkout -b twitter-experiment feature132
</span><span class='line'>$ git branch -d feature132</span></code></pre></td></tr></table></div></figure>


<p>更新：或者你可以使用 -m来切换到“git branch”（就像Mike指出，如果你只需要一个特定的分支，就可以重命名当前分支）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git branch -m twitter-experiment
</span><span class='line'>$ git branch -m feature132 twitter-experiment</span></code></pre></td></tr></table></div></figure>


<p>8.合并分支</p>

<p>以后你可能回想合并你的变动，有两种方式可以做到这一点：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git checkout master
</span><span class='line'>$ git merge feature83 # Or...
</span><span class='line'>$ git rebase feature83</span></code></pre></td></tr></table></div></figure>


<p>merge和rebase的区别是，merge会尝试解决改动并创建的新的提交来融合他们。rebase则是将从你最后一次从另一个分支分离之后的改动并入，并直接沿用另一个分支的head指针。尽管如此，在你往远端服务器上推送分支之前，不要使用rebase。这会让你混乱。</p>

<p>如果你不能确定哪个分支（哪些需要合并，哪些需要移除）。这里有两个git分支切换方式来帮助你：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># Shows branches that are all merged in to your current branch
</span><span class='line'>$ git branch --merged
</span><span class='line'>
</span><span class='line'># Shows branches that are not merged in to your current branch
</span><span class='line'>$ git branch --no-merged</span></code></pre></td></tr></table></div></figure>


<p>9.远程分支</p>

<p>如果你想将本地分支放置远程服务端，你可以用这条命令进行推送：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git push origin twitter-experiment:refs/heads/twitter-experiment
</span><span class='line'># Where origin is our server name and twitter-experiment is the branch</span></code></pre></td></tr></table></div></figure>


<p>如果你想要从服务端删除分支：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git push origin :twitter-experiment</span></code></pre></td></tr></table></div></figure>


<p>如果你想要查看远程分支的状态：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git remote show origin</span></code></pre></td></tr></table></div></figure>


<p>这将列出那些曾经存在而现在不存在的远程分支，这将帮助你轻易地删除你本地多余的分支。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git remote prune</span></code></pre></td></tr></table></div></figure>


<p>最后，如果本地追踪远程分支，常用方式是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git branch --track myfeature origin/myfeature
</span><span class='line'>$ git checkout myfeature</span></code></pre></td></tr></table></div></figure>


<p>尽管这样，Git的新版本将启动自动追踪，如果你使用-b来checkout：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git checkout -b myfeature origin/myfeature</span></code></pre></td></tr></table></div></figure>


<p>Storing Content in Stashes, Index and File System 在stash储存内容、索引和文件系统</p>

<p>10.Stashing</p>

<p>在Git中你可以将当前的工作区的内容保存到Git栈中并从最近的一次提交中读取相关内容。以下是个简单的例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git stash
</span><span class='line'># Do something...
</span><span class='line'>$ git stash pop</span></code></pre></td></tr></table></div></figure>


<p>很多人推荐使用git stash apply来代替pop。这样子恢复后储存的stash内容并不会删除，而‘pop’恢复的同时把储存的stash内容也删了 ，使用git stash apply 就可以移除任何栈中最新的内容。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git stash drop</span></code></pre></td></tr></table></div></figure>


<p>git可以自动创建基于当前提交信息的指令，如果你更喜欢使用通用的信息（相当于不会对前一次提交做任何改动）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git stash save "My stash message"</span></code></pre></td></tr></table></div></figure>


<p>如果你想使用某个stash（不一定是最后一个），你可以这样将其列表显示出来然后使用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git stash list
</span><span class='line'>  stash@{0}: On master: Changed to German
</span><span class='line'>  stash@{1}: On master: Language is now Italian
</span><span class='line'>$ git stash apply stash@{1}</span></code></pre></td></tr></table></div></figure>


<p>11.添加交互</p>

<p>在svn中，如果你文件有了改动之后，然后会提交所有改动的文件，在 Git中为了能更好的提交特定的文件或者某个补丁，你需要在交互模式提交选择提交的文件的内容。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git add -i
</span><span class='line'>staged     unstaged path
</span><span class='line'>
</span><span class='line'>*** Commands ***
</span><span class='line'>  1: status      2: update   3: revert   4: add untracked
</span><span class='line'>  5: patch      6: diff     7: quit     8: help
</span><span class='line'>What now&gt;</span></code></pre></td></tr></table></div></figure>


<p>这是基于菜单的交互式提示符。您可以使用命令前的数字或进入高亮字母(如果你有高亮输入)模式。常用形式是，输入你想执行的操作前的数字。(你可以像1或1 – 4或2、4、7的格式来执行命令)。</p>

<p>如果你想进入补丁模式（在交互模式中输入p或5），同样也可以这样操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git add -p    
</span><span class='line'>diff --git a/dummy.rb b/dummy.rb  
</span><span class='line'>index 4a00477..f856fb0 100644  
</span><span class='line'>--- a/dummy.rb
</span><span class='line'>+++ b/dummy.rb
</span><span class='line'>@@ -1,5 +1,5 @@
</span><span class='line'> class MyFoo
</span><span class='line'>   def say
</span><span class='line'>-    puts "Annyong Haseyo"
</span><span class='line'>+    puts "Guten Tag"
</span><span class='line'>   end
</span><span class='line'> end
</span><span class='line'>Stage this hunk [y,n,q,a,d,/,e,?]?</span></code></pre></td></tr></table></div></figure>


<p>如你所见，你将在选择添加改动的那部分文件的底部获得一些选项。此外，使用“？”会说明这个选项。</p>

<p>12.文件系统中的储存/检索</p>

<p>有些项目（比如Git自己的项目）需要直接在Git的文件系统中添加额外的并不想被检查的文件。</p>

<p>让我们开始在Git中保存随机文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ echo "Foo" | git hash-object -w --stdin
</span><span class='line'>51fc03a9bb365fae74fd2bf66517b30bf48020cb</span></code></pre></td></tr></table></div></figure>


<p>比如数据库中的对象，如果你不想让一些对象被垃圾回收，最简单的方式是给它加标签：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git tag myfile 51fc03a9bb365fae74fd2bf66517b30bf48020cb</span></code></pre></td></tr></table></div></figure>


<p>在这里我们设置myfile的标签，当我们需要检索该文件时可以这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git cat-file blob myfile</span></code></pre></td></tr></table></div></figure>


<p>这对开发者可能需要的但是并不想每次都去检查的有用文件（密码，gpg键等等）很管用（特别是在生产过程中）。</p>

<p>Logging and What Changed? 记录日志和什么改变了？</p>

<p>13.查看日志</p>

<p>在不使用“git log”的情况下，你不能查看你长期的最近提交内容，但是，仍然有一些更便于你使用的方法，比如，你可以这样查看单次提交变动的内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git log -p</span></code></pre></td></tr></table></div></figure>


<p>或者你只看文件变动的摘要：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git log --stat</span></code></pre></td></tr></table></div></figure>


<p>这个很赞的别名，可以让你在一行命令下简化提交，并展示不错的图形化分支。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git config --global alias.lol "log --pretty=oneline --abbrev-commit --graph --decorate"
</span><span class='line'>$ git lol
</span><span class='line'>* 4d2409a (master) Oops, meant that to be in Korean
</span><span class='line'>* 169b845 Hello world</span></code></pre></td></tr></table></div></figure>


<p>14.在日志中查找</p>

<p>如果你想根据指定的作者查找：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git log --author=XXX</span></code></pre></td></tr></table></div></figure>


<p>或者你可以搜索你提交信息的内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git log --grep="Something in the message"</span></code></pre></td></tr></table></div></figure>


<p>这些强大的指令被称为pickaxe指令，来检查被移除或添加特定块的内容（比如，当他们第一次出现或者被移除），添加任何一行内容都会告诉你（但是并不包括那行内容刚刚被改动）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git log -S "TODO: Check for admin status"</span></code></pre></td></tr></table></div></figure>


<p>如果你改动一个特定的文件会怎么样？如：lib/foo.rb</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git log lib/foo.rb</span></code></pre></td></tr></table></div></figure>


<p>如果你有feature/132 和ferature/145这两个分支，并想查看这些不在master上的分支内容。（ ^ 符号是意味着非）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git log feature/132 feature/145 ^master</span></code></pre></td></tr></table></div></figure>


<p>你同样可以使用ActiveSupport风格的日期来缩短时间范围：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git log --since=2.months.ago --until=1.day.ago</span></code></pre></td></tr></table></div></figure>


<p>默认会使用OR来合并查询，但你也可改用AND（如果你有不止一个条件）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git log --since=2.months.ago --until=1.day.ago --author=andy -S "something" --all-match</span></code></pre></td></tr></table></div></figure>


<p>15.选择试图/改动的之前的版本。</p>

<p>根据你知道的信息，可以按照以下方式来找到之前的版本：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git show 12a86bc38 # By revision
</span><span class='line'>$ git show v1.0.1 # By tag
</span><span class='line'>$ git show feature132 # By branch name
</span><span class='line'>$ git show 12a86bc38^ # Parent of a commit
</span><span class='line'>$ git show 12a86bc38~2 # Grandparent of a commit
</span><span class='line'>$ git show feature132@{yesterday} # Time relative
</span><span class='line'>$ git show feature132@{2.hours.ago} # Time relative</span></code></pre></td></tr></table></div></figure>


<p>注意：不像前一部分所说，在最后的插入符号意味着提交的父类，在前面的插入符号意味着不在这个分支上。</p>

<p>16.选择一个方式</p>

<p>最简单的方式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git log origin/master..new
</span><span class='line'># [old]..[new] - everything you haven't pushed yet</span></code></pre></td></tr></table></div></figure>


<p>你也可以省略[new]，这样将默认使用当前的HEAD指针。</p>

<p>Rewinding Time &amp; Fixing Mistakes 回滚和修复错误</p>

<p>17.重置更改</p>

<p>如果你没有提交你可以简单的撤销改动：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git reset HEAD lib/foo.rb</span></code></pre></td></tr></table></div></figure>


<p>通常我们使用”unstage“这样的别名来代替:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git config --global alias.unstage "reset HEAD"
</span><span class='line'>$ git unstage lib/foo.rb</span></code></pre></td></tr></table></div></figure>


<p>如果你已经提交了，有两种情况：如果是最后一次提交你仅仅需要amend：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git commit --amend</span></code></pre></td></tr></table></div></figure>


<p>这将不执行最后一次提交，恢复你原来的内容，提交信息将默认为你下次提交的信息。</p>

<p>如果你已经提交过不止一次了并且想完全回到之前那个记录，你可以重置分支回到指定的时间。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git checkout feature132
</span><span class='line'>$ git reset --hard HEAD~2</span></code></pre></td></tr></table></div></figure>


<p>如果你想将分支回滚但想要SHA1数（版本号）不一样（也许你可以将分支的HEAD指向另一个分支，或者之后的提交），你可以通过如下方式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git checkout FOO
</span><span class='line'>$ git reset --hard SHA</span></code></pre></td></tr></table></div></figure>


<p>实际上还有个更快的方式（这样并不会改变你的文件复制内容，并回归到第一次FOO的状态并指向SHA）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git update-ref refs/heads/FOO SHA</span></code></pre></td></tr></table></div></figure>


<p>18.提交至错误的分支</p>

<p>好吧，假定你提交到master上了，但是你想提交的是名为experimental的主题分支上，如果想移除这个改动，你可以在当前创建一个分支并将head指针回滚再检查新的分支</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git branch experimental   # Creates a pointer to the current master state
</span><span class='line'>$ git reset --hard master~3 # Moves the master branch pointer back to 3 revisions ago
</span><span class='line'>$ git checkout experimental</span></code></pre></td></tr></table></div></figure>


<p>如果你在分支的分支的分支进行了改动将会很麻烦，那么你需要做的就是在其他处进行分支rebase改动</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git branch newtopic STARTPOINT
</span><span class='line'>$ git rebase oldtopic --onto newtopic</span></code></pre></td></tr></table></div></figure>


<p>19.rebase的交互</p>

<p>这是个很不错的功能，我曾看过演示但一直以来并没有真正搞懂，现在我知道了，非常简单。假如你进行了三次提交，但是你想重新编辑它们（或者结合它们）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git rebase -i master~3</span></code></pre></td></tr></table></div></figure>


<p>然后你让你的编辑器打开一些指令，你需要做的就是修改指令来选择/squash/编辑(或删除)/提交和保存/退出，编辑完使用git rebase —continue 来通过你的每一个指令。</p>

<p>如果你选择编辑一个，它将离开你的提交状态，所以你需要使用git commit -amend来编辑它。</p>

<p>注意：不要在rebase的时候提交——只能添加了之后再使用—continue, —skip 或—abort.</p>

<p>20.清除</p>

<p>如果你在分支中提交了一些内容（也许是一些SVN上老的资源文件）并想从历史记录中完全移除，可以这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git filter-branch --tree-filter 'rm -f *.class' HEAD</span></code></pre></td></tr></table></div></figure>


<p>如果你已经将其推送至origin，并提交了一些垃圾内容，你同样可以推送之前在本地系统这样做：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git filter-branch --tree-filter 'rm -f *.class' origin/master..HEAD</span></code></pre></td></tr></table></div></figure>


<p>21.你看过的前面的引用</p>

<p>如果你知道你之前看到的SHA-1数（版本号），并需要进行一些重置/回滚，可以使用reflog命令查询最近查看的sha – 1数（版本号）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git reflog
</span><span class='line'>$ git log -g # Same as above, but shows in 'log' format</span></code></pre></td></tr></table></div></figure>


<p>22.分支命名</p>

<p>一个有趣的小技巧，不要忘记分支名不仅仅限于a-z和0-9，在名字中使用/和.用于命名伪命名空间和版本控制，也是个不错的主意，例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ # Generate a changelog of Release 132
</span><span class='line'>$ git shortlog release/132 ^release/131
</span><span class='line'>$ # Tag this as v1.0.1
</span><span class='line'>$ git tag v1.0.1 release/132</span></code></pre></td></tr></table></div></figure>


<p>23.找到Dunnit</p>

<p>找出谁在一个文件中改变了一行代码，简单的命令是:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git blame FILE</span></code></pre></td></tr></table></div></figure>


<p>有时候是上一个文件发生了变动(如果你合并两个文件，或者你已经转移到一个函数)，这样你就可以使用:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ # shows which file names the content came from
</span><span class='line'>$ git blame -C FILE</span></code></pre></td></tr></table></div></figure>


<p>有时候需要通过点击来追踪来回的变动，这里有一个不错的内置gui:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git gui blame FILE</span></code></pre></td></tr></table></div></figure>


<p>24.数据库维护</p>

<p>通常Git并不需要过多的维护，它几乎可以自己搞定，尽管如此你也可以查看数据库使用的统计：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git count-objects -v</span></code></pre></td></tr></table></div></figure>


<p>如果数值过高你可以选择将你的克隆垃圾回收。这不会影响你推送内容或其他人，但它可以让你的命令运行的更快，并使用更少的空间:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git gc</span></code></pre></td></tr></table></div></figure>


<p>它也可以在运行时进行一致性检验:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git fsck --full</span></code></pre></td></tr></table></div></figure>


<p>你可以在后面添加-auto 参数（如果你在服务器跑定时任务时），这在统计数据时是必须的。</p>

<p>当检查的结果是“dangling”或“unreachable”这样的是正常的，这通常是回滚和rebase的结果。 得到“missing” 或 “sha1 mismatch” 这样的结果是不好的…你需要得到专业的帮助!</p>

<p>25.恢复失去的分支</p>

<p>如果你意外的删除一个分支，可以重新创建它:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git branch experimental SHA1_OF_HASH</span></code></pre></td></tr></table></div></figure>


<p>你可以使用git reflog查看你最近访问过的SHA1数（版本号）</p>

<p>另一个方式就是使用 git fsck —lost-found ，悬空对象（dangling commit ）是就是失去HEAD指针的提交，（删除的分支只是失去了HEAD指针成为悬空对象）</p>

<p>Done!完成！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用cocoapods做ios程序的依赖管理]]></title>
    <link href="http://heyandev.github.io/blog/2015/01/29/yong-cocoapodszuo-ioscheng-xu-de-yi-lai-guan-li/"/>
    <updated>2015-01-29T17:40:30+08:00</updated>
    <id>http://heyandev.github.io/blog/2015/01/29/yong-cocoapodszuo-ioscheng-xu-de-yi-lai-guan-li</id>
    <content type="html"><![CDATA[<p>CocoaPods简介</p>

<p>每种语言发展到一个阶段，就会出现相应的依赖管理工具，例如Java语言的Maven，nodejs的npm。随着iOS开发者的增多，业界也出现了为iOS程序提供依赖管理的工具，它的名字叫做：<a href="http://cocoapods.org">CocoaPods</a>。</p>

<!--more-->


<p>CocoaPods<a href="https://github.com/CocoaPods/CocoaPods">项目的源码</a>在Github上管理。该项目开始于2011年8月12日，经过多年发展，现在已经成为iOS开发事实上的依赖管理标准工具。开发iOS项目不可避免地要使用第三方开源库，CocoaPods的出现使得我们可以节省设置和更新第三方开源库的时间。</p>

<p>在没有使用CocoaPods以前，我需要:</p>

<p>把这些第三方开源库的源代码文件复制到项目中，或者设置成git的submodule。
对于这些开源库通常需要依赖系统的一些framework，我需要手工地将这些framework一一增加到项目依赖中，比如通常情况下，一个网络库就需要增加以下framework: CFNetwork, SystemConfiguration, MobileCoreServices, CoreGraphics, zlib。
对于某些开源库，我还需要设置-licucore或者 -fno-objc-arc等编译参数
管理这些依赖包的更新。
这些体力活虽然简单，但毫无技术含量并且浪费时间。在使用CocoaPods之后，我只需要将用到的第三方开源库放到一个名为Podfile的文件中，然后执行pod install。CocoaPods就会自动将这些第三方开源库的源码下载下来，并且为我的工程设置好相应的系统依赖和编译参数。</p>

<p>CocoaPods的安装和使用介绍</p>

<p>安装</p>

<p>安装方式异常简单, Mac下都自带ruby，使用ruby的gem命令即可下载安装：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo gem install cocoapods
</span><span class='line'>$ pod setup</span></code></pre></td></tr></table></div></figure>


<p>如果你的gem太老，可能也会有问题，可以尝试用如下命令升级gem:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo gem update --system</span></code></pre></td></tr></table></div></figure>


<p>另外，ruby的软件源rubygems.org因为使用的亚马逊的云服务，所以被墙了，需要更新一下ruby的源，如下代码将官方的ruby源替换成国内淘宝的源：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gem sources --remove https://rubygems.org/
</span><span class='line'>gem sources -a http://ruby.taobao.org/
</span><span class='line'>gem sources -l</span></code></pre></td></tr></table></div></figure>


<p>还有一点需要注意，pod setup在执行时，会输出Setting up CocoaPods master repo，但是会等待比较久的时间。这步其实是Cocoapods在将它的信息下载到 ~/.cocoapods目录下，如果你等太久，可以试着cd到那个目录，用du -sh *来查看下载进度。你也可以参考本文接下来的使用cocoapods的镜像索引一节的内容来提高下载速度。</p>

<p>使用CocoaPods的镜像索引</p>

<p>所有的项目的Podspec文件都托管在 <a href="https://github.com/CocoaPods/Specs">https://github.com/CocoaPods/Specs</a> 。第一次执行pod setup时，CocoaPods会将这些podspec索引文件更新到本地的 ~/.cocoapods/目录下，这个索引文件比较大，有80M左右。所以第一次更新时非常慢，笔者就更新了将近1个小时才完成。</p>

<p>一个叫akinliu的朋友在gitcafe和oschina上建立了CocoaPods索引库的镜像，因为gitcafe和oschina都是国内的服务器，所以在执行索引更新操作时，会快很多。如下操作可以将CocoaPods设置成使用gitcafe镜像：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod repo remove master
</span><span class='line'>pod repo add master https://gitcafe.com/akuandev/Specs.git
</span><span class='line'>pod repo update</span></code></pre></td></tr></table></div></figure>


<p>将以上代码中的 <a href="https://gitcafe.com/akuandev/Specs.git">https://gitcafe.com/akuandev/Specs.git</a> 替换成 <a href="http://git.oschina.net/akuandev/Specs.git">http://git.oschina.net/akuandev/Specs.git</a> 即可使用oschina上的镜像。</p>

<p>使用CocoaPods</p>

<p>使用时需要新建一个名为Podfile的文件，以如下格式，将依赖的库名字依次列在文件中即可</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>platform :ios
</span><span class='line'>pod 'JSONKit',       '~&gt; 1.4'
</span><span class='line'>pod 'Reachability',  '~&gt; 3.0.0'
</span><span class='line'>pod 'ASIHTTPRequest'
</span><span class='line'>pod 'RegexKitLite'</span></code></pre></td></tr></table></div></figure>


<p>然后你将编辑好的Podfile文件放到你的项目根目录中，执行如下命令即可：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd "your project home"
</span><span class='line'>pod install</span></code></pre></td></tr></table></div></figure>


<p>现在，你的所有第三方库都已经下载完成并且设置好了编译参数和依赖，你只需要记住如下2点即可：</p>

<p>使用CocoaPods生成的 .xcworkspace 文件来打开工程，而不是以前的 .xcodeproj 文件。
每次更改了Podfile文件，你需要重新执行一次pod update命令。
查找第三方库</p>

<p>你如果不知道cocoaPods管理的库中，是否有你想要的库，那么你可以通过pod search命令进行查找，以下是我用pod search json查找到的所有可用的库：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pod search json
</span><span class='line'>
</span><span class='line'>-&gt; AnyJSON (0.0.1)
</span><span class='line'>   Encode / Decode JSON by any means possible.
</span><span class='line'>   - Homepage: https://github.com/mattt/AnyJSON
</span><span class='line'>   - Source:   https://github.com/mattt/AnyJSON.git
</span><span class='line'>   - Versions: 0.0.1 [master repo]
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>-&gt; JSONKit (1.5pre)
</span><span class='line'>   A Very High Performance Objective-C JSON Library.
</span><span class='line'>   - Homepage: https://github.com/johnezang/JSONKit
</span><span class='line'>   - Source:   git://github.com/johnezang/JSONKit.git
</span><span class='line'>   - Versions: 1.5pre, 1.4 [master repo]
</span><span class='line'>
</span><span class='line'>// ...以下省略若干行</span></code></pre></td></tr></table></div></figure>


<p>关于.gitignore</p>

<p>当你执行pod install之后，除了Podfile外，CocoaPods还会生成一个名为Podfile.lock的文件，你不应该把这个文件加入到.gitignore中。因为Podfile.lock会锁定当前各依赖库的版本，之后如果多次执行pod install 不会更改版本，要pod update才会改Podfile.lock了。这样多人协作的时候，可以防止第三方库升级时造成大家各自的第三方库版本不一致。</p>

<p>CocoaPods的这篇官方文档也在What is a Podfile.lock一节中介绍了Podfile.lock的作用，并且指出：</p>

<p>This file should always be kept under version control.</p>

<p>为自己的项目创建podspec文件</p>

<p>我们可以为自己的开源项目创建podspec文件，首先通过如下命令初始化一个podspec文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod spec create your_pod_spec_name</span></code></pre></td></tr></table></div></figure>


<p>该命令执行之后，CocoaPods会生成一个名为your_pod_spec_name.podspec的文件，然后我们修改其中的相关内容即可。</p>

<p>使用私有的pods</p>

<p>我们可以直接指定某一个依赖的podspec，这样就可以使用公司内部的私有库。该方案有利于使企业内部的公共项目支持CocoaPods。如下是一个示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod 'MyCommon', :podspec =&gt; 'https://heyandev.github.com/common/myCommon.podspec'</span></code></pre></td></tr></table></div></figure>


<p>不更新podspec</p>

<p>CocoaPods在执行pod install和pod update时，会默认先更新一次podspec索引。使用&ndash;no-repo-update参数可以禁止其做索引更新操作。如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod install --no-repo-update
</span><span class='line'>pod update --no-repo-update</span></code></pre></td></tr></table></div></figure>


<p>生成第三方库的帮助文档</p>

<p>如果你想让CococaPods帮你生成第三方库的帮助文档，并集成到Xcode中，那么用brew安装appledoc即可：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>brew install appledoc</span></code></pre></td></tr></table></div></figure>


<p>关于appledoc，它最大的优点是可以将帮助文档集成到Xcode中，这样你在敲代码的时候，按住opt键单击类名或方法名，就可以显示出相应的帮助文档。</p>

<p>原理</p>

<p>大概研究了一下CocoaPods的原理，它是将所有的依赖库都放到另一个名为Pods项目中，然后让主项目依赖Pods项目，这样，源码管理工作都从主项目移到了Pods项目中。发现的一些技术细节有：</p>

<p>Pods项目最终会编译成一个名为libPods.a的文件，主项目只需要依赖这个.a文件即可。
对于资源文件，CocoaPods提供了一个名为Pods-resources.sh的bash脚本，该脚本在每次项目编译的时候都会执行，将第三方库的各种资源文件复制到目标目录中。
CocoaPods通过一个名为Pods.xcconfig的文件来在编译时设置所有的依赖和参数。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Github上搭建Octopress博客]]></title>
    <link href="http://heyandev.github.io/blog/2015/01/29/zai-githubshang-da-jian-octopressbo-ke/"/>
    <updated>2015-01-29T13:21:50+08:00</updated>
    <id>http://heyandev.github.io/blog/2015/01/29/zai-githubshang-da-jian-octopressbo-ke</id>
    <content type="html"><![CDATA[<p>安装Octopress博客前需在本机上安装Ruby运行环境和Devkit，另外还要下载Octopress，更改gem的更新源，安装依赖项。本文将针对Github上的Octopress博客搭建进行详细说明。</p>

<!--more-->


<p>一、搭建本地环境</p>

<p>为了在Github上使用Octopress，需要首先配置一下本地环境：</p>

<p>首先安装Git，下载<a href="https://code.google.com/p/msysgit/downloads/list">msysgit</a>，目前最新版本是 <a href="http://msysgit.googlecode.com/files/Git-1.7.10-preview20120409.exe">Git-1.7.10-preview20120409.exe</a> ，安装可参考<a href="https://help.github.com/articles/set-up-git/">官方文档</a>。</p>

<p>然后安装Ruby， <a href="http://octopress.org/docs/setup/">Octopress 官方文档</a>中指定的 Ruby 版本是 1.9.2，所以我们选择 Ruby 1.9.2-p290，下载 <a href="http://rubyforge.org/frs/download.php/75127/rubyinstaller-1.9.2-p290.exe">rubyinstaller-1.9.2-p290.exe</a>，双击安装，安装时记得选中“Add Ruby executables to your PATH”。</p>

<p>为了检查ruby是否已加入到PATH中，可在 Windows 的cmd窗口中执行以下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ruby –version</span></code></pre></td></tr></table></div></figure>


<p>接着安装Devkit，选择下载 4.5.2 版本:<a href="https://github.com/downloads/oneclick/rubyinstaller/DevKit-tdm-32-4.5.2-20111229-1559-sfx.exe">DevKit-tdm-32-4.5.2-20111229-1559-sfx.exe</a>，下载完成后，将其解压到如 E:\DevKit，然后在win的cmd窗口中执行如下命令进行安装：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>E:
</span><span class='line'>cd DevKit
</span><span class='line'>ruby dk.rb init
</span><span class='line'>ruby dk.rb install</span></code></pre></td></tr></table></div></figure>


<p>最后安装python，主要是博客代码加亮模块需要python环境的支持，<a href="http://www.activestate.com/activepython/downloads">下载2.7版</a>，安装完以后，在Windows的cmd窗口中执行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>easy_install pygments</span></code></pre></td></tr></table></div></figure>


<p>本地环境配置结束。</p>

<p>二、更新本地环境配置
为了支持中文UTF-8编码，对Windows环境变量配置如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>LANG=zh_CN.UTF-8
</span><span class='line'>LC_ALL=zh_CN.UTF-8</span></code></pre></td></tr></table></div></figure>


<p>也可在直接在Windows的cmd窗口下运行命令</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>set LANG=zh_CN.UTF-8
</span><span class='line'>set LC_ALL=zh_CN.UTF-8</span></code></pre></td></tr></table></div></figure>


<p>更新gem的更新源，ruby的官方更新源经常被河蟹，换成国内的更新源，这样速度就快多了，变更如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gem sources -a http://ruby.taobao.org/
</span><span class='line'>gem sources -r http://rubygems.org/
</span><span class='line'>gem sources -l</span></code></pre></td></tr></table></div></figure>


<p>最后一个命令可查看更该后的更新源列表。</p>

<p>三、下载并配置Octopress
首先下载Octopress源码，可以使用下面git命令下载，也可直接在Octopress Github库中下载octopress的zip包<a href="https://nodeload.github.com/imathis/octopress/zipball/master">（点击下载）</a>，然后将下载的压缩包解压到E盘根目录，修改解压后的文件夹名称为 octopress。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>E:
</span><span class='line'>git clone git://github.com/imathis/octopress.git  octopress</span></code></pre></td></tr></table></div></figure>


<p>然后更新 Octopress 的gem更新源：进到 E:octopress 目录，用文本编辑器（例如记事本）打开文件Gemfile，将里面source &ldquo;<a href="http://rubygems.org/">http://rubygems.org/</a>&#8220;改为source &#8221;<a href="http://ruby.taobao.org/">http://ruby.taobao.org/</a>&#8220;。</p>

<p>最后安装Octopress的依赖项，在Windows的CMD窗口输入以下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>E:
</span><span class='line'>cd octopress
</span><span class='line'>gem install bundler
</span><span class='line'>bundle install</span></code></pre></td></tr></table></div></figure>


<p>四、新建Github Repositories
登录<a href="http://github.com">Github</a>，假设你的用户名是username，首先要新建一个命名为 username.github.com 的Repo，命名必须是这个格式，如果不这样命名的话，在运行命令 rake setup_github_pages  之后不能够自动创建后面提到的master和source 分支，而是作为普通仓库生成 gh-pages 分支。</p>

<p>五、发布Octopress到Github
1、打开Windows下的命令窗口，进入到Octopress所在的目录，输入命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake setup_github_pages</span></code></pre></td></tr></table></div></figure>


<p>按照提示输入刚才新建的Repo地址，类似：git@github.com:username/username.github.com或git@github.com:username/username.github.com.git。</p>

<p>2、接着输入命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake install
</span><span class='line'>rake generate
</span><span class='line'>rake preview</span></code></pre></td></tr></table></div></figure>


<p>其中rake install是安装Octopress默认主题的，rake gnerate是生成静态页面的，这两个命令是必须运行的，而rake preview则是用来本地浏览的（运行时看屏幕上提示，按Ctrl+C并输入Y来终止批处理操作），运行后打开浏览器，输入 <a href="http://localhost:4000/">http://localhost:4000/</a> 就可以看到界面了，不想预览的话也可以不运行，直接进入下一步。</p>

<p>3、将博客发布到Github上，输入下面命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake deploy</span></code></pre></td></tr></table></div></figure>


<p>这样，生成的内容将会自动发布到master分支，并且可以使用 <a href="http://username.github.com">http://username.github.com</a> 访问内容。</p>

<p>4、别忘了把所有源文件发布到 source 分支下面：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git add .
</span><span class='line'>git commit -m “your message”
</span><span class='line'>git push origin source</span></code></pre></td></tr></table></div></figure>


<p>至此，所有发布完成，接下来就是对博客的设置了。</p>

<p>六、Ocotpress博客配置
更改下面的配置后，还需要运行 rake generate、rake deploy等等命令的。</p>

<p>1、默认的博客运行成功的话，就需要按照自己的要求对博客配置进行修改了，主要是修改Octopress根目录下的主配置文件_config.yml。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>url:  http://username.github.com                 # 博客地址
</span><span class='line'>title:  蔓草札记                                            # 博客标题
</span><span class='line'>subtitle:  感受生活，感悟工作，感触心灵           # 副标题
</span><span class='line'>author:  xhhjin                                                       # 作者
</span><span class='line'>simple_search:  http://www.google.com.hk/search     # 搜索引擎
</span><span class='line'>description:                                                            # 关于博客的描述
</span><span class='line'>subscribe_rss:  /atom.xml                  # Rss订阅地址, 默认是  /atom.xml
</span><span class='line'>subscribe_email:                               # 提供Email订阅的地址
</span><span class='line'>email:                                              # Rss订阅的Email地址
</span><span class='line'>root:  /               # 博客路径，默认是“/“，如果你打算在子目录中，记得修改这个路径
</span><span class='line'>permalink: /blog/:year/:month/:day/:title/           # 文章的固定链接形式</span></code></pre></td></tr></table></div></figure>


<p>2、更换主题</p>

<p>主题位于 octopress/.theme 目录下，默认主题为 classic。 如果需要更改主题（可在网上查找），下载后将主题也放在.theme目录下即可，如果主题名字为blog_theme，那么安装主题时输入以下命令即可：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake install [‘blog_theme’]</span></code></pre></td></tr></table></div></figure>


<p>七、绑定域名
Github Pages绑定域名的方法有点特殊，需要在Octopress/source目录下建个无后缀的CNAME文本文件，文件内容就是你的域名，例如github.xuhehuan.com，然后修改A纪录到207.97.227.245 ，或者 CNAME 指向 username.github.com，下面就等着解析生效了</p>
]]></content>
  </entry>
  
</feed>
