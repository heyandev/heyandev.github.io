<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[heyandev github Blog]]></title>
  <link href="http://heyandev.github.io/atom.xml" rel="self"/>
  <link href="http://heyandev.github.io/"/>
  <updated>2015-02-10T09:57:00+08:00</updated>
  <id>http://heyandev.github.io/</id>
  <author>
    <name><![CDATA[heyan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Clone Your Octopress to Blog From Two Places]]></title>
    <link href="http://heyandev.github.io/blog/2015/02/10/clone-your-octopress-to-blog-from-two-places/"/>
    <updated>2015-02-10T09:56:22+08:00</updated>
    <id>http://heyandev.github.io/blog/2015/02/10/clone-your-octopress-to-blog-from-two-places</id>
    <content type="html"><![CDATA[<p>Clone Your Octopress to Blog From Two Places</p>

<p>This post covers how recreate a local repository of your Octopress blog. Perhaps you’ve accidentally lost it, or perhaps you would like to be able to blog from two different places. Recently I bought a new computer and I wanted to be able to blog from both my desktop and my laptop.</p>

<!--more-->


<p>How Octopress works</p>

<p>Octopress repositories have two branches, source and master. The source branch contains the files that are used to generate the blog and the master contains the blog itself.</p>

<p>When the local folders are initially configured according to the <a href="http://octopress.org/docs/setup/">Octopress Setup Guide</a>, the master branch is stored in a subfolder named ‘_deploy’. Since the folder name begins with an underscore, it is ignored when you git push origin source. Instead, the master branch (which contains your blog posts) gets updated when you rake deploy.</p>

<p>Recreating a local Octopress repository</p>

<p>To recreate the local directory structure of an existing Octopress blog, follow these instructions.</p>

<p>Clone your blog to the new machine</p>

<p>First you need to clone the source branch to the local octopress folder.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git clone -b source git@github.com:username/username.github.com.git octopress</span></code></pre></td></tr></table></div></figure>


<p>Then clone the master branch to the _deploy subfolder.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd octopress
</span><span class='line'>$ git clone git@github.com:username/username.github.com.git _deploy </span></code></pre></td></tr></table></div></figure>


<p>Then run the rake installation to configure everything</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ gem install bundler
</span><span class='line'>$ rbenv rehash    # If you use rbenv, rehash to be able to run the bundle command
</span><span class='line'>$ bundle install
</span><span class='line'>$ rake setup_github_pages</span></code></pre></td></tr></table></div></figure>


<p>It will prompt you for your repository URL.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Enter the read/write url for your repository
</span><span class='line'>(For example, 'git@github.com:your_username/your_username.github.com)</span></code></pre></td></tr></table></div></figure>


<p>That’s you setup with a new local copy of your Octopress blog.</p>

<p>Pushing changes from two different machines</p>

<p>If you want to blog from more than one computer, you need to make sure that you push everything before switching computers. From the first machine do the following whenever you’ve made changes:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ rake generate
</span><span class='line'>$ git add .
</span><span class='line'>$ git commit -am "Some comment here." 
</span><span class='line'>$ git push origin source  # update the remote source branch 
</span><span class='line'>$ rake deploy             # update the remote master branch</span></code></pre></td></tr></table></div></figure>


<p>Then on the other machine, you need to pull those changes.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ cd octopress
</span><span class='line'>$ git pull origin source  # update the local source branch
</span><span class='line'>$ cd ./_deploy
</span><span class='line'>$ git pull origin master  # update the local master branch</span></code></pre></td></tr></table></div></figure>


<p>Of course, it might be easier to deploy everything from a thumb drive instead…</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发ARC内存管理技术要点]]></title>
    <link href="http://heyandev.github.io/blog/2015/02/10/ioskai-fa-arcnei-cun-guan-li-ji-zhu-yao-dian/"/>
    <updated>2015-02-10T09:29:18+08:00</updated>
    <id>http://heyandev.github.io/blog/2015/02/10/ioskai-fa-arcnei-cun-guan-li-ji-zhu-yao-dian</id>
    <content type="html"><![CDATA[<p>iOS开发ARC内存管理技术要点</p>

<p>本文来源于我个人的ARC学习笔记，旨在通过简明扼要的方式总结出iOS开发中ARC(Automatic Reference Counting，自动引用计数)内存管理技术的要点，所以不会涉及全部细节。这篇文章不是一篇标准的ARC使用教程，并假定读者已经对ARC有了一定了解和使用经验。详细的关于ARC的信息请参见苹果的<a href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html">官方文档</a>与网上的其他教程：）</p>

<!--more-->


<p>本文的主要内容：</p>

<p>ARC的本质
ARC的开启与关闭
ARC的修饰符
ARC与Block
ARC与Toll-Free Bridging
ARC的本质</p>

<p>ARC是编译器（时）特性，而不是运行时特性，更不是垃圾回收器(GC)。</p>

<p>Automatic Reference Counting (ARC) is a compiler-level feature that simplifies the process of managing object lifetimes (memory management) in Cocoa applications.</p>

<p>ARC只是相对于MRC（Manual Reference Counting或称为非ARC，下文中我们会一直使用MRC来指代非ARC的管理方式）的一次改进，但它和之前的技术本质上没有区别。具体信息可以参考<a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html">ARC编译器官方文档</a>。</p>

<p>ARC的开启与关闭</p>

<p>不同于XCode4可以在创建工程时选择关闭ARC，XCode5在创建的工程是默认开启ARC，没有可以关闭ARC的选项。</p>

<p>如果需要对特定文件开启或关闭ARC，可以在工程选项中选择Targets -> Compile Phases -> Compile Sources，在里面找到对应文件，添加flag:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>打开ARC：-fobjc-arc
</span><span class='line'>关闭ARC：-fno-objc-arc</span></code></pre></td></tr></table></div></figure>


<p>ARC的修饰符</p>

<p>ARC主要提供了4种修饰符，他们分别是:<strong>strong,</strong>weak,<strong>autoreleasing,</strong>unsafe_unretained。</p>

<p>__strong
表示引用为强引用。对应在定义property时的&#8221;strong&#8221;。所有对象只有当没有任何一个强引用指向时，才会被释放。</p>

<p>注意：如果在声明引用时不加修饰符，那么引用将默认是强引用。当需要释放强引用指向的对象时，需要将强引用置nil。</p>

<p><strong>weak
表示引用为弱引用。对应在定义property时用的&#8221;weak&#8221;。弱引用不会影响对象的释放，即只要对象没有任何强引用指向，即使有100个弱引用对象指向也没用，该对象依然会被释放。不过好在，对象在被释放的同时，指向它的弱引用会自动被置nil，这个技术叫zeroing weak pointer。这样有效得防止无效指针、野指针的产生。</strong>weak一般用在delegate关系中防止循环引用或者用来修饰指向由Interface Builder编辑与生成的UI控件。</p>

<p>__autoreleasing
表示在autorelease pool中自动释放对象的引用，和MRC时代autorelease的用法相同。定义property时不能使用这个修饰符，任何一个对象的property都不应该是autorelease型的。</p>

<p>一个常见的误解是，在ARC中没有autorelease，因为这样一个“自动释放”看起来好像有点多余。这个误解可能源自于将ARC的“自动”和autorelease“自动”的混淆。其实你只要看一下每个iOS App的main.m文件就能知道，autorelease不仅好好的存在着，并且变得更fashion了：不需要再手工被创建，也不需要再显式得调用[drain]方法释放内存池。</p>

<p>以下两行代码的意义是相同的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSString *str = [[[NSString alloc] initWithFormat:@"hehe"] autorelease]; // MRC
</span><span class='line'>NSString *__autoreleasing str = [[NSString alloc] initWithFormat:@"hehe"]; // ARC</span></code></pre></td></tr></table></div></figure>


<p> 这里关于autoreleasepool就不做展开了，详细地信息可以参考官方文档或者其他文章。</p>

<p>__autoreleasing在ARC中主要用在参数传递返回值（out-parameters）和引用传递参数（pass-by-reference）的情况下。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>__autoreleasing is used to denote arguments that are passed by reference (id *) and are autoreleased on return.</span></code></pre></td></tr></table></div></figure>


<p>比如常用的NSError的使用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSError *__autoreleasing error; 
</span><span class='line'>if (![data writeToFile:filename options:NSDataWritingAtomic error:&error]) 
</span><span class='line'>{ 
</span><span class='line'>　　NSLog(, error); 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>（在上面的writeToFile方法中error参数的类型为(NSError <em>__autoreleasing </em>)）</p>

<p>注意，如果你的error定义为了strong型，那么，编译器会帮你隐式地做如下事情，保证最终传入函数的参数依然是个__autoreleasing类型的引用。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSError *error; 
</span><span class='line'>NSError *__autoreleasing tempError = error; // 编译器添加 
</span><span class='line'>if (![data writeToFile:filename options:NSDataWritingAtomic error:&tempError]) 
</span><span class='line'>{ 
</span><span class='line'>　　error = tempError; // 编译器添加 
</span><span class='line'>　　NSLog(@"Error: %@", error); 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>所以为了提高效率，避免这种情况，我们一般在定义error的时候将其（老老实实地=。=）声明为__autoreleasing类型的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSError *__autoreleasing error;</span></code></pre></td></tr></table></div></figure>


<p>在这里，加上__autoreleasing之后，相当于在MRC中对返回值error做了如下事情：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>*error = [[[NSError alloc] init] autorelease];</span></code></pre></td></tr></table></div></figure>


<p><em>error指向的对象在创建出来后，被放入到了autoreleasing pool中，等待使用结束后的自动释放，函数外error的使用者并不需要关心</em>error指向对象的释放。</p>

<p>另外一点，在ARC中，所有这种指针的指针 （NSError **）的函数参数如果不加修饰符，编译器会默认将他们认定为__autoreleasing类型。</p>

<p>比如下面的两段代码是等同的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (NSString *)doSomething:(NSNumber **)value
</span><span class='line'>{
</span><span class='line'>        // do something  
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (NSString *)doSomething:(NSNumber * __autoreleasing *)value
</span><span class='line'>{
</span><span class='line'>        // do something  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>除非你显式得给value声明了<strong>strong，否则value默认就是</strong>autoreleasing的。</p>

<p>最后一点，某些类的方法会隐式地使用自己的autorelease pool，在这种时候使用__autoreleasing类型要特别小心。</p>

<p>比如NSDictionary的[enumerateKeysAndObjectsUsingBlock]方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error
</span><span class='line'>{
</span><span class='line'>    [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop){
</span><span class='line'> 
</span><span class='line'>          // do stuff  
</span><span class='line'>          if (there is some error && error != nil)
</span><span class='line'>          {
</span><span class='line'>                *error = [NSError errorWithDomain:@"MyError" ?code:1 userInfo:nil];
</span><span class='line'>          }
</span><span class='line'>
</span><span class='line'>    }];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>会隐式地创建一个autorelease pool，上面代码实际类似于：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error
</span><span class='line'>{
</span><span class='line'>    [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop){
</span><span class='line'> 
</span><span class='line'>          @autoreleasepool  // 被隐式创建
</span><span class='line'>　　　　　　{
</span><span class='line'>              if (there is some error && error != nil)
</span><span class='line'>              {
</span><span class='line'>                    *error = [NSError errorWithDomain:@"MyError" ?code:1 userInfo:nil];
</span><span class='line'>              }
</span><span class='line'>          }
</span><span class='line'>    }];
</span><span class='line'> 
</span><span class='line'>    // *error 在这里已经被dict的做枚举遍历时创建的autorelease pool释放掉了 ：(  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>为了能够正常的使用*error，我们需要一个strong型的临时引用，在dict的枚举Block中是用这个临时引用，保证引用指向的对象不会在出了dict的枚举Block后被释放，正确的方式如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error
</span><span class='line'>{
</span><span class='line'>　　__block NSError* tempError; // 加__block保证可以在Block内被修改  
</span><span class='line'>　　[dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop)
</span><span class='line'>　　{ 
</span><span class='line'>　　　　if (there is some error) 
</span><span class='line'>　　　　{ 
</span><span class='line'>　　　　　　*tempError = [NSError errorWithDomain:@"MyError" ?code:1 userInfo:nil]; 
</span><span class='line'>　　　　}  
</span><span class='line'> 
</span><span class='line'>　　}] 
</span><span class='line'> 
</span><span class='line'>　　if (error != nil) 
</span><span class='line'>　　{ 
</span><span class='line'>　　　　*error = tempError; 
</span><span class='line'>　　} 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>__unsafe_unretained
ARC是在iOS 5引入的，而这个修饰符主要是为了在ARC刚发布时兼容iOS 4以及版本更低的设备，因为这些版本的设备没有weak pointer system，简单的理解这个系统就是我们上面讲weak时提到的，能够在weak引用指向对象被释放后，把引用值自动设为nil的系统。这个修饰符在定义property时对应的是&#8221;unsafe_unretained&#8221;，实际可以将它理解为MRC时代的assign：纯粹只是将引用指向对象，没有任何额外的操作，在指向对象被释放时依然原原本本地指向原来被释放的对象（所在的内存区域）。所以非常不安全。</p>

<p>现在可以完全忽略掉这个修饰符了，因为iOS 4早已退出历史舞台很多年。</p>

<p>*使用修饰符的正确姿势（方式=。=）
这可能是很多人都不知道的一个问题，包括之前的我，但却是一个特别要注意的问题。</p>

<p>苹果的文档中明确地写道：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>You should decorate variables correctly. When using qualifiers in an object variable declaration,
</span><span class='line'>
</span><span class='line'>the correct format is:
</span><span class='line'>
</span><span class='line'>ClassName * qualifier variableName;</span></code></pre></td></tr></table></div></figure>


<p>按照这个说明，要定义一个weak型的NSString引用，它的写法应该是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSString * __weak str = @"hehe"; // 正确！
</span><span class='line'>而不应该是：
</span><span class='line'>
</span><span class='line'>__weak NSString *str = @"hehe";  // 错误！</span></code></pre></td></tr></table></div></figure>


<p>我相信很多人都和我一样，从开始用ARC就一直用上面那种错误的写法。</p>

<p>那这里就有疑问了，既然文档说是错误的，为啥编译器不报错呢？文档又解释道：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Other variants are technically incorrect but are “forgiven” by the compiler. To understand the issue, seehttp://cdecl.org/.</span></code></pre></td></tr></table></div></figure>


<p>好吧，看来是苹果爸爸（=.=）考虑到很多人会用错，所以在编译器这边贴心地帮我们忽略并处理掉了这个错误，虽然不报错，但是我们还是应该按照正确的方式去使用这些修饰符，如果你以前也常常用错误的写法，那看到这里记得以后不要这么写了，哪天编译器怒了，再不支持错误的写法，就要郁闷了。</p>

<p>栈中指针默认值为nil
无论是被strong，weak还是autoreleasing修饰，声明在栈中的指针默认值都会是nil。所有这类型的指针不用再初始化的时候置nil了。虽然好习惯是最重要的，但是这个特性更加降低了“野指针”出现的可能性。</p>

<p>在ARC中，以下代码会输出null而不是crash:)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)myMethod 
</span><span class='line'>{
</span><span class='line'>    NSString *name;
</span><span class='line'>    NSLog(@"name: %@", name);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>ARC与Block</p>

<p>在MRC时代，Block会隐式地对进入其作用域内的对象（或者说被Block捕获的指针指向的对象）加retain，来确保Block使用到该对象时，能够正确的访问。</p>

<p>这件事情在下面代码展示的情况中要更加额外小心。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MyViewController *myController = [[MyViewController alloc] init…];
</span><span class='line'> 
</span><span class='line'>// 隐式地调用[myController retain];造成循环引用
</span><span class='line'>myController.completionHandler =  ^(NSInteger result) {
</span><span class='line'>   [myController dismissViewControllerAnimated:YES completion:nil];
</span><span class='line'>};
</span><span class='line'> 
</span><span class='line'>[self presentViewController:myController animated:YES completion:^{
</span><span class='line'>   [myController release]; // 注意，这里调用[myController release];是在MRC中的一个常规写法，并不能解决上面循环引用的问题
</span><span class='line'>}];</span></code></pre></td></tr></table></div></figure>


<p>在这段代码中，myController的completionHandler调用了myController的方法[dismissViewController&hellip;]，这时completionHandler会对myController做retain操作。而我们知道，myController对completionHandler也至少有一个retain（一般准确讲是copy），这时就出现了在内存管理中最糟糕的情况：循环引用！简单点说就是：myController retain了completionHandler，而completionHandler也retain了myController。循环引用导致了myController和completionHandler最终都不能被释放。我们在delegate关系中，对delegate指针用weak就是为了避免这种问题。</p>

<p>不过好在，编译器会及时地给我们一个警告，提醒我们可能会发生这类型的问题：</p>

<p>对这种情况，我们一般用如下方法解决：给要进入Block的指针加一个__block修饰符。</p>

<p>这个__block在MRC时代有两个作用：</p>

<p>说明变量可改
说明指针指向的对象不做这个隐式的retain操作
一个变量如果不加<strong>block，是不能在Block里面修改的，不过这里有一个例外：static的变量和全局变量不需要加</strong>block就可以在Block中修改。</p>

<p>使用这种方法，我们对代码做出修改，解决了循环引用的问题：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MyViewController * __block myController = [[MyViewController alloc] init…];
</span><span class='line'>// ...
</span><span class='line'>myController.completionHandler =  ^(NSInteger result) {
</span><span class='line'>    [myController dismissViewControllerAnimated:YES completion:nil];
</span><span class='line'>};
</span><span class='line'>//之后正常的release或者retain</span></code></pre></td></tr></table></div></figure>


<p>在ARC引入后，没有了retain和release等操作，情况也发生了改变：在任何情况下，<strong>block修饰符的作用只有上面的第一条：说明变量可改。即使加上了</strong>block修饰符，一个被block捕获的强引用也依然是一个强引用。这样在ARC下，如果我们还按照MRC下的写法，completionHandler对myController有一个强引用，而myController对completionHandler有一个强引用，这依然是循环引用，没有解决问题：（</p>

<p>于是我们还需要对原代码做修改。简单的情况我们可以这样写：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>__block MyViewController * myController = [[MyViewController alloc] init…];
</span><span class='line'>// ...
</span><span class='line'>myController.completionHandler =  ^(NSInteger result) {
</span><span class='line'>    [myController dismissViewControllerAnimated:YES completion:nil];
</span><span class='line'>    myController = nil;  // 注意这里，保证了block结束myController强引用的解除
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>在completionHandler之后将myController指针置nil，保证了completionHandler对myController强引用的解除，不过也同时解除了myController对myController对象的强引用。这种方法过于简单粗暴了，在大多数情况下，我们有更好的方法。</p>

<p>这个更好的方法就是使用weak。（或者为了考虑iOS4的兼容性用unsafe_unretained，具体用法和weak相同，考虑到现在iOS4设备可能已经绝迹了，这里就不讲这个方法了）（关于这个方法的本质我们后面会谈到）</p>

<p>为了保证completionHandler这个Block对myController没有强引用，我们可以定义一个临时的弱引用weakMyViewController来指向原myController的对象，并把这个弱引用传入到Block内，这样就保证了Block对myController持有的是一个弱引用，而不是一个强引用。如此，我们继续修改代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MyViewController *myController = [[MyViewController alloc] init…];
</span><span class='line'>// ...
</span><span class='line'>MyViewController * __weak weakMyViewController = myController;
</span><span class='line'>myController.completionHandler =  ^(NSInteger result) {
</span><span class='line'>    [weakMyViewController dismissViewControllerAnimated:YES completion:nil];
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>这样循环引用的问题就解决了，但是却不幸地引入了一个新的问题：由于传入completionHandler的是一个弱引用，那么当myController指向的对象在completionHandler被调用前释放，那么completionHandler就不能正常的运作了。在一般的单线程环境中，这种问题出现的可能性不大，但是到了多线程环境，就很不好说了，所以我们需要继续完善这个方法。</p>

<p>为了保证在Block内能够访问到正确的myController，我们在block内新定义一个强引用strongMyController来指向weakMyController指向的对象，这样多了一个强引用，就能保证这个myController对象不会在completionHandler被调用前释放掉了。于是，我们对代码再次做出修改：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MyViewController *myController = [[MyViewController alloc] init…];
</span><span class='line'>// ...
</span><span class='line'>MyViewController * __weak weakMyController = myController;
</span><span class='line'>myController.completionHandler =  ^(NSInteger result) {
</span><span class='line'>    MyViewController *strongMyController = weakMyController;
</span><span class='line'> 
</span><span class='line'>　　if (strongMyController) {
</span><span class='line'>        // ...
</span><span class='line'>        [strongMyController dismissViewControllerAnimated:YES completion:nil];
</span><span class='line'>        // ...
</span><span class='line'>    }
</span><span class='line'>    else {
</span><span class='line'>        // Probably nothing...
</span><span class='line'>    }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>到此，一个完善的解决方案就完成了：）</p>

<p>官方文档对这个问题的说明到这里就结束了，但是可能很多朋友会有疑问，不是说不希望Block对原myController对象增加强引用么，这里为啥堂而皇之地在Block内新定义了一个强引用，这个强引用不会造成循环引用么？理解这个问题的关键在于理解被Block捕获的引用和在Block内定义的引用的区别。为了搞得明白这个问题，这里需要了解一些Block的实现原理，但由于篇幅的缘故，本文在这里就不展开了，详细的内容可以参考其他的文章。</p>

<p>这里假设大家已经对Block的实现原理有所了解了。我们就直入主题了！注意前方高能（=。=）</p>

<p>为了更清楚地说明问题，这里用一个简单的程序举例。比如我们有如下程序：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include &lt; stdio.h&gt;
</span><span class='line'> 
</span><span class='line'>int main()
</span><span class='line'>{
</span><span class='line'>    int b = 10;
</span><span class='line'>     
</span><span class='line'>    int *a = &b;
</span><span class='line'>     
</span><span class='line'>    void (^blockFunc)() = ^(){
</span><span class='line'>     
</span><span class='line'>        int *c = a;
</span><span class='line'> 
</span><span class='line'>    };
</span><span class='line'>     
</span><span class='line'>    blockFunc();
</span><span class='line'>     
</span><span class='line'>    return 1;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>程序中，同为int型的指针，a是被Block捕获的变量，而c是在Block内定义的变量。我们用clang -rewrite-objc处理后，可以看到如下代码：</p>

<p>原main函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int main()
</span><span class='line'>{
</span><span class='line'>    int b = 10;
</span><span class='line'> 
</span><span class='line'>    int *a = &b;
</span><span class='line'> 
</span><span class='line'>    void (*blockFunc)() = (void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, a);
</span><span class='line'> 
</span><span class='line'>    ((void (*)(__block_impl *))((__block_impl *)blockFunc)-&gt;FuncPtr)((__block_impl *)blockFunc);
</span><span class='line'> 
</span><span class='line'>    return 1;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Block的结构：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct __main_block_impl_0 {
</span><span class='line'>  struct __block_impl impl;
</span><span class='line'>  struct __main_block_desc_0* Desc;
</span><span class='line'>   
</span><span class='line'>  int *a; // 被捕获的引用 a 出现在了block的结构体里面
</span><span class='line'>   
</span><span class='line'>  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_a, int flags=0) : a(_a) {
</span><span class='line'>    impl.isa = &_NSConcreteStackBlock;
</span><span class='line'>    impl.Flags = flags;
</span><span class='line'>    impl.FuncPtr = fp;
</span><span class='line'>    Desc = desc;
</span><span class='line'>  }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>实际执行的函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
</span><span class='line'>  int *a = __cself-&gt;a; // bound by copy
</span><span class='line'> 
</span><span class='line'> 
</span><span class='line'>        int *c = a; // 在block中声明的引用 c 在函数中声明，存在于函数栈上
</span><span class='line'> 
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>我们可以清楚得看到，a和c存在的位置完全不同，如果Block存在于堆上（在ARC下Block默认在堆上），那么a作为Block结构体的一个成员，也自然会存在于堆上，而c无论如何，永远位于Block内实际执行代码的函数栈内。这也导致了两个变量生命周期的完全不同：c在Block的函数运行完毕，即会被释放，而a呢，只有在Block被从堆上释放的时候才会释放。</p>

<p>回到我们的MyViewController的例子中，同上理，如果我们直接让Block捕获我们的myController引用，那么这个引用会被复制后（引用类型也会被复制）作为Block的成员变量存在于其所在的堆空间中，也就是为Block增加了一个指向myController对象的强引用，这就是造成循环引用的本质原因。对于MyViewController的例子，Block的结构体可以理解是这个样子：（准确的结构体肯定和以下这个有区别，但也肯定是如下这种形式：）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct __main_block_impl_0 {
</span><span class='line'>  struct __block_impl impl;
</span><span class='line'>  struct __main_block_desc_0* Desc;
</span><span class='line'>   
</span><span class='line'>  MyViewController * __strong myController;  // 被捕获的强引用myController
</span><span class='line'>   
</span><span class='line'>  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_a, int flags=0) : a(_a) {
</span><span class='line'>    impl.isa = &_NSConcreteStackBlock;
</span><span class='line'>    impl.Flags = flags;
</span><span class='line'>    impl.FuncPtr = fp;
</span><span class='line'>    Desc = desc;
</span><span class='line'>  }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>而反观我们给Block传入一个弱引用weakMyController，这时我们Block的结构：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>struct __main_block_impl_0 {
</span><span class='line'>  struct __block_impl impl;
</span><span class='line'>  struct __main_block_desc_0* Desc;
</span><span class='line'>   
</span><span class='line'>  MyViewController * __weak weakMyController;  // 被捕获的弱引用weakMyController
</span><span class='line'>   
</span><span class='line'>  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_a, int flags=0) : a(_a) {
</span><span class='line'>    impl.isa = &_NSConcreteStackBlock;
</span><span class='line'>    impl.Flags = flags;
</span><span class='line'>    impl.FuncPtr = fp;
</span><span class='line'>    Desc = desc;
</span><span class='line'>  }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>再看在Block内声明的强引用strongMyController，它虽然是强引用，但存在于函数栈中，在函数执行期间，它一直存在，所以myController对象也一直存在，但是当函数执行完毕，strongMyController即被销毁，于是它对myController对象的强引用也被解除，这时Block对myController对象就不存在强引用关系了！加入了strongMyController的函数大体会是这个样子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
</span><span class='line'> 
</span><span class='line'>  MyViewController * __strong strongMyController = __cself-&gt;weakMyController; 
</span><span class='line'> 
</span><span class='line'>    // ....
</span><span class='line'> 
</span><span class='line'>    }</span></code></pre></td></tr></table></div></figure>


<p>综上所述，在ARC下（在MRC下会略有不同），Block捕获的引用和Block内声明的引用无论是存在空间与生命周期都是截然不同的，也正是这种不同，造成了我们对他们使用方式的区别。</p>

<p>以上就解释了之前提到的所有问题，希望大家能看明白：）</p>

<p>好的，最后再提一点，在ARC中，对Block捕获对象的内存管理已经简化了很多，由于没有了retain和release等操作，实际只需要考虑循环引用的问题就行了。比如下面这种，是没有内存泄露的问题的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>TestObject *aObject = [[TestObject alloc] init];
</span><span class='line'>     
</span><span class='line'>aObject.name = @"hehe";
</span><span class='line'> 
</span><span class='line'>self.aBlock = ^(){
</span><span class='line'>     
</span><span class='line'>    NSLog(@"aObject's name = %@",aObject.name);
</span><span class='line'>         
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>我们上面提到的解决方案，只是针对Block产生循环引用的问题，而不是说所有的Block捕获引用都要这么处理，一定要注意！</p>

<p>ARC与Toll-Free Bridging</p>

<p>There are a number of data types in the Core Foundation framework and the Foundation framework that can be used interchangeably. This capability, called toll-free bridging, means that you can use the same data type as the parameter to a Core Foundation function call or as the receiver of an Objective-C message.</p>

<p>Toll-Free Briding保证了在程序中，可以方便和谐的使用Core Foundation类型的对象和Objective-C类型的对象。详细的内容可参考官方文档。以下是官方文档中给出的一些例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSLocale *gbNSLocale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_GB"];
</span><span class='line'>CFLocaleRef gbCFLocale = (CFLocaleRef) gbNSLocale;
</span><span class='line'>CFStringRef cfIdentifier = CFLocaleGetIdentifier (gbCFLocale);
</span><span class='line'>NSLog(@"cfIdentifier: %@", (NSString *)cfIdentifier);
</span><span class='line'>// logs: "cfIdentifier: en_GB"
</span><span class='line'>CFRelease((CFLocaleRef) gbNSLocale);
</span><span class='line'>  
</span><span class='line'>CFLocaleRef myCFLocale = CFLocaleCopyCurrent();
</span><span class='line'>NSLocale * myNSLocale = (NSLocale *) myCFLocale;
</span><span class='line'>[myNSLocale autorelease];
</span><span class='line'>NSString *nsIdentifier = [myNSLocale localeIdentifier];
</span><span class='line'>CFShow((CFStringRef) [@"nsIdentifier: " stringByAppendingString:nsIdentifier]);
</span><span class='line'>// logs identifier for current locale</span></code></pre></td></tr></table></div></figure>


<p>在MRC时代，由于Objective-C类型的对象和Core Foundation类型的对象都是相同的release和retain操作规则，所以Toll-Free Bridging的使用比较简单，但是自从ARC加入后，Objective-C类型的对象内存管理规则改变了，而Core Foundation依然是之前的机制，换句话说，Core Foundation不支持ARC。</p>

<p>这个时候就必须要要考虑一个问题了，在做Core Foundation与Objective-C类型转换的时候，用哪一种规则来管理对象的内存。显然，对于同一个对象，我们不能够同时用两种规则来管理，所以这里就必须要确定一件事情：哪些对象用Objective-C（也就是ARC）的规则，哪些对象用Core Foundation的规则（也就是MRC）的规则。或者说要确定对象类型转换了之后，内存管理的ownership的改变。</p>

<p>If you cast between Objective-C and Core Foundation-style objects, you need to tell the compiler about the ownership semantics of the object using either a cast (defined in objc/runtime.h) or a Core Foundation-style macro (defined inNSObject.h)</p>

<p>于是苹果在引入ARC之后对Toll-Free Bridging的操作也加入了对应的方法与修饰符，用来指明用哪种规则管理内存，或者说是内存管理权的归属。</p>

<p>这些方法和修饰符分别是：</p>

<p>__bridge（修饰符）
只是声明类型转变，但是不做内存管理规则的转变。</p>

<p>比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CFStringRef s1 = (__bridge CFStringRef) [[NSString alloc] initWithFormat:@"Hello, %@!", name];</span></code></pre></td></tr></table></div></figure>


<p>只是做了NSString到CFStringRef的转化，但管理规则未变，依然要用Objective-C类型的ARC来管理s1，你不能用CFRelease()去释放s1。</p>

<p>__bridge_retained（修饰符） or CFBridgingRetain（函数）
表示将指针类型转变的同时，将内存管理的责任由原来的Objective-C交给Core Foundation来处理，也就是，将ARC转变为MRC。</p>

<p>比如，还是上面那个例子</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSString *s1 = [[NSString alloc] initWithFormat:@"Hello, %@!", name];
</span><span class='line'>?CFStringRef s2 = (__bridge_retained CFStringRef)s1;
</span><span class='line'>// do something with s2
</span><span class='line'>//...
</span><span class='line'>CFRelease(s2); // 注意要在使用结束后加这个</span></code></pre></td></tr></table></div></figure>


<p>我们在第二行做了转化，这时内存管理规则由ARC变为了MRC，我们需要手动的来管理s2的内存，而对于s1，我们即使将其置为nil，也不能释放内存。</p>

<p>等同的，我们的程序也可以写成：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSString *s1 = [[NSString alloc] initWithFormat:@"Hello, %@!", name];
</span><span class='line'>CFStringRef s2 = (CFStringRef)CFBridgingRetain(s1);
</span><span class='line'>// do something with s2
</span><span class='line'>//...
</span><span class='line'>CFRelease(s2); // 注意要在使用结束后加这个</span></code></pre></td></tr></table></div></figure>


<p><strong>bridge_transfer（修饰符） or CFBridgingRelease（函数）
这个修饰符和函数的功能和上面那个</strong>bridge_retained相反，它表示将管理的责任由Core Foundation转交给Objective-C，即将管理方式由MRC转变为ARC。</p>

<p>比如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>CFStringRef result = CFURLCreateStringByAddingPercentEscapes(. . .);
</span><span class='line'>NSString *s = (__bridge_transfer NSString *)result;
</span><span class='line'>//or NSString *s = (NSString *)CFBridgingRelease(result);
</span><span class='line'>return s;</span></code></pre></td></tr></table></div></figure>


<p>这里我们将result的管理责任交给了ARC来处理，我们就不需要再显式地将CFRelease()了。</p>

<p>对了，这里你可能会注意到一个细节，和ARC中那个4个主要的修饰符（<strong>strong,</strong>weak,&hellip;）不同，这里修饰符的位置是放在类型前面的，虽然官方文档中没有说明，但看官方的头文件可以知道。小伙伴们，记得别把位置写错哦：）</p>

<p>呼~ 好了，以上就是本篇文章的主要内容。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[25个Git用法技巧]]></title>
    <link href="http://heyandev.github.io/blog/2015/02/06/25ge-gityong-fa-ji-qiao/"/>
    <updated>2015-02-06T09:38:24+08:00</updated>
    <id>http://heyandev.github.io/blog/2015/02/06/25ge-gityong-fa-ji-qiao</id>
    <content type="html"><![CDATA[<p>作为一个很享受git的人，我想要分享从各种社区学到的实用经验，让大家不需要花费过多的功夫就能找到答案。</p>

<!--more-->


<p>基本技巧</p>

<p>1.安装后的第一步</p>

<p>安装git后，第一件事你需要设置你的名字和邮箱，因为每次提交都需要这些信息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git config --global user.name "Some One"
</span><span class='line'>$ git config --global user.email "someone@gmail.com"</span></code></pre></td></tr></table></div></figure>


<p>2.是基于指针的</p>

<p>git上的所有东西都是储存在文件里的，当你创建一次提交时，它会创建一个包含你的提交信息和相关数据（名字，邮箱，日期/时间、上一次提交等等）的文件并连接一个树文件，而这个树文件包含了对象列表或者其他树。这上面的对象或者blob文件就是这次提交的实际内容（你可以认为这也是一个文件，尽管并没有储存在对象里而是储存在树中）。所有的文件都以经过SHA-1计算后的文件名（译者注：经过SHA-1计算后的数，即git中的版本号）储存在上面。</p>

<p>从这里可以看出，分支和标签都是包含一个指向这次提交的sha-1数（版本号）简单的文件，这样使用引用会变得更快和更灵活，创建一个新的分支是就像创建文件一样简单，SHA – 1数（版本号）也会引用你这个分支的提交。当然，如果你使用GIT命令行工具（或者GUI）你将无法接触这些。但真的很简单。</p>

<p>你可能听说过HEAD引用，这是一个指向你当前提交的内容的SHA-1 数（版本号）的指针。如果你正在解决合并冲突，使用HEAD不会对你的特定分支有任何改动只会指向你当前的分支。</p>

<p>所有分支的指针都保存在 .git/refs/heads，HEAD指针保存在.git/HEAD，标签则保存在 .git/refs/tags，有时间就去看看吧。</p>

<p>3.两个母体（Parent），当然！</p>

<p>当我们在日志文件中查看合并提交信息，你会看到两个母体，第一个母体是正在进行的分支，第二个是你要合并的分支。</p>

<p>4.合并冲突</p>

<p>现在，我发现有合并冲突并解决了它，这是一件在我们编辑文件时很正常的事。将 &lt;&lt;&lt;&lt;, ====, >>>> 这些标记移除后，并保存你想要保存的代码。有些时候在代码被直接替代之前，能看到冲突是件挺不错的事。比如在两个冲突的分支变动之前，可以用这样的命令方式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git diff --merge
</span><span class='line'>diff --cc dummy.rb  
</span><span class='line'>index 5175dde,0c65895..4a00477  
</span><span class='line'>--- a/dummy.rb
</span><span class='line'>+++ b/dummy.rb
</span><span class='line'>@@@ -1,5 -1,5 +1,5 @@@
</span><span class='line'>  class MyFoo
</span><span class='line'>    def say
</span><span class='line'>-     puts "Bonjour"
</span><span class='line'> -    puts "Hello world"
</span><span class='line'>++    puts "Annyong Haseyo"
</span><span class='line'>    end
</span><span class='line'>  end
</span><span class='line'>
</span><span class='line'>If the file is binary, diffing files isn’t so easy… What you’ll normally want to do is to try each version of the binary file and decide which one to use (or manually copy portions over in the binary file’s editor). To pull a copy of the file from a particular branch (say you’re merging master and feature132):</span></code></pre></td></tr></table></div></figure>


<p>如果是二进制文件（binary），区别这些文件并不容易。通常你会查看每个二进制文件的版本，再决定使用哪个（或者在二进制文件编辑器中手动复制），并将其推送至特定的分支。（比如你要合并master和feature132）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git checkout master flash/foo.fla # or...
</span><span class='line'>$ git checkout feature132 flash/foo.fla
</span><span class='line'>$ # Then...
</span><span class='line'>$ git add flash/foo.fla
</span><span class='line'>
</span><span class='line'>Another way is to cat the file from git – you can do this to another filename then copy the correct file over (when you’ve decided which it is) to the normal filename:</span></code></pre></td></tr></table></div></figure>


<p>另一个方法就是在git中cat文件，你可以将其命名为另一个文件名，然后将你决定的那个文件改为正确的文件名：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git show master:flash/foo.fla &gt; master-foo.fla
</span><span class='line'>$ git show feature132:flash/foo.fla &gt; feature132-foo.fla
</span><span class='line'>$ # Check out master-foo.fla and feature132-foo.fla
</span><span class='line'>$ # Let's say we decide that feature132's is correct
</span><span class='line'>$ rm flash/foo.fla
</span><span class='line'>$ mv feature132-foo.fla flash/foo.fla
</span><span class='line'>$ rm master-foo.fla
</span><span class='line'>$ git add flash/foo.fla</span></code></pre></td></tr></table></div></figure>


<p>更新：可以使用 “git checkout —ours flash/foo.fla” 和“git checkout —theirs flash/foo.fla” 在不用考虑你需要合并的分支来检查指定版本，就我个人而言，我喜欢更明确的方法，但这也是一个选择…</p>

<p>记住，解决完合并冲突后要添加文件。（我之前就犯过这样的错误）</p>

<p>服务，分支和标注</p>

<p>5.远程服务</p>

<p>Git有一个非常强大的特性，就是可以有多个远程服务端（以及你运行的一个本地仓库）。你不需要总是进行访问，你可以有多个服务端并能从其中一个（合并工作）读取再写入另一个。添加一个远程服务端很简单：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git remote add john git@github.com:johnsomeone/someproject.git
</span><span class='line'>
</span><span class='line'>If you want to see information about your remote servers you can do:</span></code></pre></td></tr></table></div></figure>


<p>如果你想查看远程服务端的信息你可以：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># shows URLs of each remote server
</span><span class='line'>$ git remote -v 
</span><span class='line'>
</span><span class='line'># gives more details about each
</span><span class='line'>$ git remote show name 
</span><span class='line'>
</span><span class='line'>You can always see the differences between a local branch and a remote branch:</span></code></pre></td></tr></table></div></figure>


<p>你总是能看到本地分支和远程分支不同的地方：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git diff master..john/master
</span><span class='line'>
</span><span class='line'>You can also see the changes on HEAD that aren’t on that remote branch:</span></code></pre></td></tr></table></div></figure>


<p>你同样也能看到远程分支上没有的HEAD指针的改动：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git log remote/branch..
</span><span class='line'># Note: no final refspec after ..</span></code></pre></td></tr></table></div></figure>


<p>6.Tagging 标签</p>

<p>在Git中有两种类型的标注：轻量级标注和注释型标注。</p>

<p>记住第二个是Git的指针基础，两者区别很简单，轻量级标注是简单命名提交的指针，你可以将其指向另一个提交。注释型标注是一个有信息和历史并指向标注对象的名字指针，它有着自己的信息，如果需要的话，可以进行GPG标记。</p>

<p>创建两种类型的标签很简单（其中一个命令行有改动）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git tag to-be-tested
</span><span class='line'>$ git tag -a v1.1.0 # Prompts for a tag message</span></code></pre></td></tr></table></div></figure>


<p>7.Creating Branches 创建分支</p>

<p>在git中创建分支是件非常简单的事情（非常快并只需要不到100byte的文件大小）。创建新分支并切换到该分支，通常是下面这样的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git branch feature132
</span><span class='line'>$ git checkout feature132</span></code></pre></td></tr></table></div></figure>


<p>当然，如果你想切换到该分支，最直接的方式是使用这样一条命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git checkout -b feature132</span></code></pre></td></tr></table></div></figure>


<p>如果你想要重新命名本地分支，也很简单：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git checkout -b twitter-experiment feature132
</span><span class='line'>$ git branch -d feature132</span></code></pre></td></tr></table></div></figure>


<p>更新：或者你可以使用 -m来切换到“git branch”（就像Mike指出，如果你只需要一个特定的分支，就可以重命名当前分支）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git branch -m twitter-experiment
</span><span class='line'>$ git branch -m feature132 twitter-experiment</span></code></pre></td></tr></table></div></figure>


<p>8.合并分支</p>

<p>以后你可能回想合并你的变动，有两种方式可以做到这一点：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git checkout master
</span><span class='line'>$ git merge feature83 # Or...
</span><span class='line'>$ git rebase feature83</span></code></pre></td></tr></table></div></figure>


<p>merge和rebase的区别是，merge会尝试解决改动并创建的新的提交来融合他们。rebase则是将从你最后一次从另一个分支分离之后的改动并入，并直接沿用另一个分支的head指针。尽管如此，在你往远端服务器上推送分支之前，不要使用rebase。这会让你混乱。</p>

<p>如果你不能确定哪个分支（哪些需要合并，哪些需要移除）。这里有两个git分支切换方式来帮助你：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># Shows branches that are all merged in to your current branch
</span><span class='line'>$ git branch --merged
</span><span class='line'>
</span><span class='line'># Shows branches that are not merged in to your current branch
</span><span class='line'>$ git branch --no-merged</span></code></pre></td></tr></table></div></figure>


<p>9.远程分支</p>

<p>如果你想将本地分支放置远程服务端，你可以用这条命令进行推送：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git push origin twitter-experiment:refs/heads/twitter-experiment
</span><span class='line'># Where origin is our server name and twitter-experiment is the branch</span></code></pre></td></tr></table></div></figure>


<p>如果你想要从服务端删除分支：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git push origin :twitter-experiment</span></code></pre></td></tr></table></div></figure>


<p>如果你想要查看远程分支的状态：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git remote show origin</span></code></pre></td></tr></table></div></figure>


<p>这将列出那些曾经存在而现在不存在的远程分支，这将帮助你轻易地删除你本地多余的分支。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git remote prune</span></code></pre></td></tr></table></div></figure>


<p>最后，如果本地追踪远程分支，常用方式是：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git branch --track myfeature origin/myfeature
</span><span class='line'>$ git checkout myfeature</span></code></pre></td></tr></table></div></figure>


<p>尽管这样，Git的新版本将启动自动追踪，如果你使用-b来checkout：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git checkout -b myfeature origin/myfeature</span></code></pre></td></tr></table></div></figure>


<p>Storing Content in Stashes, Index and File System 在stash储存内容、索引和文件系统</p>

<p>10.Stashing</p>

<p>在Git中你可以将当前的工作区的内容保存到Git栈中并从最近的一次提交中读取相关内容。以下是个简单的例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git stash
</span><span class='line'># Do something...
</span><span class='line'>$ git stash pop</span></code></pre></td></tr></table></div></figure>


<p>很多人推荐使用git stash apply来代替pop。这样子恢复后储存的stash内容并不会删除，而‘pop’恢复的同时把储存的stash内容也删了 ，使用git stash apply 就可以移除任何栈中最新的内容。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git stash drop</span></code></pre></td></tr></table></div></figure>


<p>git可以自动创建基于当前提交信息的指令，如果你更喜欢使用通用的信息（相当于不会对前一次提交做任何改动）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git stash save "My stash message"</span></code></pre></td></tr></table></div></figure>


<p>如果你想使用某个stash（不一定是最后一个），你可以这样将其列表显示出来然后使用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git stash list
</span><span class='line'>  stash@{0}: On master: Changed to German
</span><span class='line'>  stash@{1}: On master: Language is now Italian
</span><span class='line'>$ git stash apply stash@{1}</span></code></pre></td></tr></table></div></figure>


<p>11.添加交互</p>

<p>在svn中，如果你文件有了改动之后，然后会提交所有改动的文件，在 Git中为了能更好的提交特定的文件或者某个补丁，你需要在交互模式提交选择提交的文件的内容。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git add -i
</span><span class='line'>staged     unstaged path
</span><span class='line'>
</span><span class='line'>*** Commands ***
</span><span class='line'>  1: status      2: update   3: revert   4: add untracked
</span><span class='line'>  5: patch      6: diff     7: quit     8: help
</span><span class='line'>What now&gt;</span></code></pre></td></tr></table></div></figure>


<p>这是基于菜单的交互式提示符。您可以使用命令前的数字或进入高亮字母(如果你有高亮输入)模式。常用形式是，输入你想执行的操作前的数字。(你可以像1或1 – 4或2、4、7的格式来执行命令)。</p>

<p>如果你想进入补丁模式（在交互模式中输入p或5），同样也可以这样操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git add -p    
</span><span class='line'>diff --git a/dummy.rb b/dummy.rb  
</span><span class='line'>index 4a00477..f856fb0 100644  
</span><span class='line'>--- a/dummy.rb
</span><span class='line'>+++ b/dummy.rb
</span><span class='line'>@@ -1,5 +1,5 @@
</span><span class='line'> class MyFoo
</span><span class='line'>   def say
</span><span class='line'>-    puts "Annyong Haseyo"
</span><span class='line'>+    puts "Guten Tag"
</span><span class='line'>   end
</span><span class='line'> end
</span><span class='line'>Stage this hunk [y,n,q,a,d,/,e,?]?</span></code></pre></td></tr></table></div></figure>


<p>如你所见，你将在选择添加改动的那部分文件的底部获得一些选项。此外，使用“？”会说明这个选项。</p>

<p>12.文件系统中的储存/检索</p>

<p>有些项目（比如Git自己的项目）需要直接在Git的文件系统中添加额外的并不想被检查的文件。</p>

<p>让我们开始在Git中保存随机文件</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ echo "Foo" | git hash-object -w --stdin
</span><span class='line'>51fc03a9bb365fae74fd2bf66517b30bf48020cb</span></code></pre></td></tr></table></div></figure>


<p>比如数据库中的对象，如果你不想让一些对象被垃圾回收，最简单的方式是给它加标签：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git tag myfile 51fc03a9bb365fae74fd2bf66517b30bf48020cb</span></code></pre></td></tr></table></div></figure>


<p>在这里我们设置myfile的标签，当我们需要检索该文件时可以这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git cat-file blob myfile</span></code></pre></td></tr></table></div></figure>


<p>这对开发者可能需要的但是并不想每次都去检查的有用文件（密码，gpg键等等）很管用（特别是在生产过程中）。</p>

<p>Logging and What Changed? 记录日志和什么改变了？</p>

<p>13.查看日志</p>

<p>在不使用“git log”的情况下，你不能查看你长期的最近提交内容，但是，仍然有一些更便于你使用的方法，比如，你可以这样查看单次提交变动的内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git log -p</span></code></pre></td></tr></table></div></figure>


<p>或者你只看文件变动的摘要：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git log --stat</span></code></pre></td></tr></table></div></figure>


<p>这个很赞的别名，可以让你在一行命令下简化提交，并展示不错的图形化分支。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git config --global alias.lol "log --pretty=oneline --abbrev-commit --graph --decorate"
</span><span class='line'>$ git lol
</span><span class='line'>* 4d2409a (master) Oops, meant that to be in Korean
</span><span class='line'>* 169b845 Hello world</span></code></pre></td></tr></table></div></figure>


<p>14.在日志中查找</p>

<p>如果你想根据指定的作者查找：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git log --author=XXX</span></code></pre></td></tr></table></div></figure>


<p>或者你可以搜索你提交信息的内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git log --grep="Something in the message"</span></code></pre></td></tr></table></div></figure>


<p>这些强大的指令被称为pickaxe指令，来检查被移除或添加特定块的内容（比如，当他们第一次出现或者被移除），添加任何一行内容都会告诉你（但是并不包括那行内容刚刚被改动）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git log -S "TODO: Check for admin status"</span></code></pre></td></tr></table></div></figure>


<p>如果你改动一个特定的文件会怎么样？如：lib/foo.rb</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git log lib/foo.rb</span></code></pre></td></tr></table></div></figure>


<p>如果你有feature/132 和ferature/145这两个分支，并想查看这些不在master上的分支内容。（ ^ 符号是意味着非）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git log feature/132 feature/145 ^master</span></code></pre></td></tr></table></div></figure>


<p>你同样可以使用ActiveSupport风格的日期来缩短时间范围：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git log --since=2.months.ago --until=1.day.ago</span></code></pre></td></tr></table></div></figure>


<p>默认会使用OR来合并查询，但你也可改用AND（如果你有不止一个条件）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git log --since=2.months.ago --until=1.day.ago --author=andy -S "something" --all-match</span></code></pre></td></tr></table></div></figure>


<p>15.选择试图/改动的之前的版本。</p>

<p>根据你知道的信息，可以按照以下方式来找到之前的版本：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git show 12a86bc38 # By revision
</span><span class='line'>$ git show v1.0.1 # By tag
</span><span class='line'>$ git show feature132 # By branch name
</span><span class='line'>$ git show 12a86bc38^ # Parent of a commit
</span><span class='line'>$ git show 12a86bc38~2 # Grandparent of a commit
</span><span class='line'>$ git show feature132@{yesterday} # Time relative
</span><span class='line'>$ git show feature132@{2.hours.ago} # Time relative</span></code></pre></td></tr></table></div></figure>


<p>注意：不像前一部分所说，在最后的插入符号意味着提交的父类，在前面的插入符号意味着不在这个分支上。</p>

<p>16.选择一个方式</p>

<p>最简单的方式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git log origin/master..new
</span><span class='line'># [old]..[new] - everything you haven't pushed yet</span></code></pre></td></tr></table></div></figure>


<p>你也可以省略[new]，这样将默认使用当前的HEAD指针。</p>

<p>Rewinding Time &amp; Fixing Mistakes 回滚和修复错误</p>

<p>17.重置更改</p>

<p>如果你没有提交你可以简单的撤销改动：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git reset HEAD lib/foo.rb</span></code></pre></td></tr></table></div></figure>


<p>通常我们使用”unstage“这样的别名来代替:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git config --global alias.unstage "reset HEAD"
</span><span class='line'>$ git unstage lib/foo.rb</span></code></pre></td></tr></table></div></figure>


<p>如果你已经提交了，有两种情况：如果是最后一次提交你仅仅需要amend：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git commit --amend</span></code></pre></td></tr></table></div></figure>


<p>这将不执行最后一次提交，恢复你原来的内容，提交信息将默认为你下次提交的信息。</p>

<p>如果你已经提交过不止一次了并且想完全回到之前那个记录，你可以重置分支回到指定的时间。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git checkout feature132
</span><span class='line'>$ git reset --hard HEAD~2</span></code></pre></td></tr></table></div></figure>


<p>如果你想将分支回滚但想要SHA1数（版本号）不一样（也许你可以将分支的HEAD指向另一个分支，或者之后的提交），你可以通过如下方式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git checkout FOO
</span><span class='line'>$ git reset --hard SHA</span></code></pre></td></tr></table></div></figure>


<p>实际上还有个更快的方式（这样并不会改变你的文件复制内容，并回归到第一次FOO的状态并指向SHA）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git update-ref refs/heads/FOO SHA</span></code></pre></td></tr></table></div></figure>


<p>18.提交至错误的分支</p>

<p>好吧，假定你提交到master上了，但是你想提交的是名为experimental的主题分支上，如果想移除这个改动，你可以在当前创建一个分支并将head指针回滚再检查新的分支</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git branch experimental   # Creates a pointer to the current master state
</span><span class='line'>$ git reset --hard master~3 # Moves the master branch pointer back to 3 revisions ago
</span><span class='line'>$ git checkout experimental</span></code></pre></td></tr></table></div></figure>


<p>如果你在分支的分支的分支进行了改动将会很麻烦，那么你需要做的就是在其他处进行分支rebase改动</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git branch newtopic STARTPOINT
</span><span class='line'>$ git rebase oldtopic --onto newtopic</span></code></pre></td></tr></table></div></figure>


<p>19.rebase的交互</p>

<p>这是个很不错的功能，我曾看过演示但一直以来并没有真正搞懂，现在我知道了，非常简单。假如你进行了三次提交，但是你想重新编辑它们（或者结合它们）。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git rebase -i master~3</span></code></pre></td></tr></table></div></figure>


<p>然后你让你的编辑器打开一些指令，你需要做的就是修改指令来选择/squash/编辑(或删除)/提交和保存/退出，编辑完使用git rebase —continue 来通过你的每一个指令。</p>

<p>如果你选择编辑一个，它将离开你的提交状态，所以你需要使用git commit -amend来编辑它。</p>

<p>注意：不要在rebase的时候提交——只能添加了之后再使用—continue, —skip 或—abort.</p>

<p>20.清除</p>

<p>如果你在分支中提交了一些内容（也许是一些SVN上老的资源文件）并想从历史记录中完全移除，可以这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git filter-branch --tree-filter 'rm -f *.class' HEAD</span></code></pre></td></tr></table></div></figure>


<p>如果你已经将其推送至origin，并提交了一些垃圾内容，你同样可以推送之前在本地系统这样做：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git filter-branch --tree-filter 'rm -f *.class' origin/master..HEAD</span></code></pre></td></tr></table></div></figure>


<p>21.你看过的前面的引用</p>

<p>如果你知道你之前看到的SHA-1数（版本号），并需要进行一些重置/回滚，可以使用reflog命令查询最近查看的sha – 1数（版本号）：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git reflog
</span><span class='line'>$ git log -g # Same as above, but shows in 'log' format</span></code></pre></td></tr></table></div></figure>


<p>22.分支命名</p>

<p>一个有趣的小技巧，不要忘记分支名不仅仅限于a-z和0-9，在名字中使用/和.用于命名伪命名空间和版本控制，也是个不错的主意，例如：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ # Generate a changelog of Release 132
</span><span class='line'>$ git shortlog release/132 ^release/131
</span><span class='line'>$ # Tag this as v1.0.1
</span><span class='line'>$ git tag v1.0.1 release/132</span></code></pre></td></tr></table></div></figure>


<p>23.找到Dunnit</p>

<p>找出谁在一个文件中改变了一行代码，简单的命令是:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git blame FILE</span></code></pre></td></tr></table></div></figure>


<p>有时候是上一个文件发生了变动(如果你合并两个文件，或者你已经转移到一个函数)，这样你就可以使用:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ # shows which file names the content came from
</span><span class='line'>$ git blame -C FILE</span></code></pre></td></tr></table></div></figure>


<p>有时候需要通过点击来追踪来回的变动，这里有一个不错的内置gui:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git gui blame FILE</span></code></pre></td></tr></table></div></figure>


<p>24.数据库维护</p>

<p>通常Git并不需要过多的维护，它几乎可以自己搞定，尽管如此你也可以查看数据库使用的统计：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git count-objects -v</span></code></pre></td></tr></table></div></figure>


<p>如果数值过高你可以选择将你的克隆垃圾回收。这不会影响你推送内容或其他人，但它可以让你的命令运行的更快，并使用更少的空间:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git gc</span></code></pre></td></tr></table></div></figure>


<p>它也可以在运行时进行一致性检验:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git fsck --full</span></code></pre></td></tr></table></div></figure>


<p>你可以在后面添加-auto 参数（如果你在服务器跑定时任务时），这在统计数据时是必须的。</p>

<p>当检查的结果是“dangling”或“unreachable”这样的是正常的，这通常是回滚和rebase的结果。 得到“missing” 或 “sha1 mismatch” 这样的结果是不好的…你需要得到专业的帮助!</p>

<p>25.恢复失去的分支</p>

<p>如果你意外的删除一个分支，可以重新创建它:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ git branch experimental SHA1_OF_HASH</span></code></pre></td></tr></table></div></figure>


<p>你可以使用git reflog查看你最近访问过的SHA1数（版本号）</p>

<p>另一个方式就是使用 git fsck —lost-found ，悬空对象（dangling commit ）是就是失去HEAD指针的提交，（删除的分支只是失去了HEAD指针成为悬空对象）</p>

<p>Done!完成！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用cocoapods做ios程序的依赖管理]]></title>
    <link href="http://heyandev.github.io/blog/2015/01/29/yong-cocoapodszuo-ioscheng-xu-de-yi-lai-guan-li/"/>
    <updated>2015-01-29T17:40:30+08:00</updated>
    <id>http://heyandev.github.io/blog/2015/01/29/yong-cocoapodszuo-ioscheng-xu-de-yi-lai-guan-li</id>
    <content type="html"><![CDATA[<p>CocoaPods简介</p>

<p>每种语言发展到一个阶段，就会出现相应的依赖管理工具，例如Java语言的Maven，nodejs的npm。随着iOS开发者的增多，业界也出现了为iOS程序提供依赖管理的工具，它的名字叫做：<a href="http://cocoapods.org">CocoaPods</a>。</p>

<!--more-->


<p>CocoaPods<a href="https://github.com/CocoaPods/CocoaPods">项目的源码</a>在Github上管理。该项目开始于2011年8月12日，经过多年发展，现在已经成为iOS开发事实上的依赖管理标准工具。开发iOS项目不可避免地要使用第三方开源库，CocoaPods的出现使得我们可以节省设置和更新第三方开源库的时间。</p>

<p>在没有使用CocoaPods以前，我需要:</p>

<p>把这些第三方开源库的源代码文件复制到项目中，或者设置成git的submodule。
对于这些开源库通常需要依赖系统的一些framework，我需要手工地将这些framework一一增加到项目依赖中，比如通常情况下，一个网络库就需要增加以下framework: CFNetwork, SystemConfiguration, MobileCoreServices, CoreGraphics, zlib。
对于某些开源库，我还需要设置-licucore或者 -fno-objc-arc等编译参数
管理这些依赖包的更新。
这些体力活虽然简单，但毫无技术含量并且浪费时间。在使用CocoaPods之后，我只需要将用到的第三方开源库放到一个名为Podfile的文件中，然后执行pod install。CocoaPods就会自动将这些第三方开源库的源码下载下来，并且为我的工程设置好相应的系统依赖和编译参数。</p>

<p>CocoaPods的安装和使用介绍</p>

<p>安装</p>

<p>安装方式异常简单, Mac下都自带ruby，使用ruby的gem命令即可下载安装：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo gem install cocoapods
</span><span class='line'>$ pod setup</span></code></pre></td></tr></table></div></figure>


<p>如果你的gem太老，可能也会有问题，可以尝试用如下命令升级gem:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo gem update --system</span></code></pre></td></tr></table></div></figure>


<p>另外，ruby的软件源rubygems.org因为使用的亚马逊的云服务，所以被墙了，需要更新一下ruby的源，如下代码将官方的ruby源替换成国内淘宝的源：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gem sources --remove https://rubygems.org/
</span><span class='line'>gem sources -a http://ruby.taobao.org/
</span><span class='line'>gem sources -l</span></code></pre></td></tr></table></div></figure>


<p>还有一点需要注意，pod setup在执行时，会输出Setting up CocoaPods master repo，但是会等待比较久的时间。这步其实是Cocoapods在将它的信息下载到 ~/.cocoapods目录下，如果你等太久，可以试着cd到那个目录，用du -sh *来查看下载进度。你也可以参考本文接下来的使用cocoapods的镜像索引一节的内容来提高下载速度。</p>

<p>使用CocoaPods的镜像索引</p>

<p>所有的项目的Podspec文件都托管在 <a href="https://github.com/CocoaPods/Specs">https://github.com/CocoaPods/Specs</a> 。第一次执行pod setup时，CocoaPods会将这些podspec索引文件更新到本地的 ~/.cocoapods/目录下，这个索引文件比较大，有80M左右。所以第一次更新时非常慢，笔者就更新了将近1个小时才完成。</p>

<p>一个叫akinliu的朋友在gitcafe和oschina上建立了CocoaPods索引库的镜像，因为gitcafe和oschina都是国内的服务器，所以在执行索引更新操作时，会快很多。如下操作可以将CocoaPods设置成使用gitcafe镜像：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod repo remove master
</span><span class='line'>pod repo add master https://gitcafe.com/akuandev/Specs.git
</span><span class='line'>pod repo update</span></code></pre></td></tr></table></div></figure>


<p>将以上代码中的 <a href="https://gitcafe.com/akuandev/Specs.git">https://gitcafe.com/akuandev/Specs.git</a> 替换成 <a href="http://git.oschina.net/akuandev/Specs.git">http://git.oschina.net/akuandev/Specs.git</a> 即可使用oschina上的镜像。</p>

<p>使用CocoaPods</p>

<p>使用时需要新建一个名为Podfile的文件，以如下格式，将依赖的库名字依次列在文件中即可</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>platform :ios
</span><span class='line'>pod 'JSONKit',       '~&gt; 1.4'
</span><span class='line'>pod 'Reachability',  '~&gt; 3.0.0'
</span><span class='line'>pod 'ASIHTTPRequest'
</span><span class='line'>pod 'RegexKitLite'</span></code></pre></td></tr></table></div></figure>


<p>然后你将编辑好的Podfile文件放到你的项目根目录中，执行如下命令即可：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd "your project home"
</span><span class='line'>pod install</span></code></pre></td></tr></table></div></figure>


<p>现在，你的所有第三方库都已经下载完成并且设置好了编译参数和依赖，你只需要记住如下2点即可：</p>

<p>使用CocoaPods生成的 .xcworkspace 文件来打开工程，而不是以前的 .xcodeproj 文件。
每次更改了Podfile文件，你需要重新执行一次pod update命令。
查找第三方库</p>

<p>你如果不知道cocoaPods管理的库中，是否有你想要的库，那么你可以通过pod search命令进行查找，以下是我用pod search json查找到的所有可用的库：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ pod search json
</span><span class='line'>
</span><span class='line'>-&gt; AnyJSON (0.0.1)
</span><span class='line'>   Encode / Decode JSON by any means possible.
</span><span class='line'>   - Homepage: https://github.com/mattt/AnyJSON
</span><span class='line'>   - Source:   https://github.com/mattt/AnyJSON.git
</span><span class='line'>   - Versions: 0.0.1 [master repo]
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>-&gt; JSONKit (1.5pre)
</span><span class='line'>   A Very High Performance Objective-C JSON Library.
</span><span class='line'>   - Homepage: https://github.com/johnezang/JSONKit
</span><span class='line'>   - Source:   git://github.com/johnezang/JSONKit.git
</span><span class='line'>   - Versions: 1.5pre, 1.4 [master repo]
</span><span class='line'>
</span><span class='line'>// ...以下省略若干行</span></code></pre></td></tr></table></div></figure>


<p>关于.gitignore</p>

<p>当你执行pod install之后，除了Podfile外，CocoaPods还会生成一个名为Podfile.lock的文件，你不应该把这个文件加入到.gitignore中。因为Podfile.lock会锁定当前各依赖库的版本，之后如果多次执行pod install 不会更改版本，要pod update才会改Podfile.lock了。这样多人协作的时候，可以防止第三方库升级时造成大家各自的第三方库版本不一致。</p>

<p>CocoaPods的这篇官方文档也在What is a Podfile.lock一节中介绍了Podfile.lock的作用，并且指出：</p>

<p>This file should always be kept under version control.</p>

<p>为自己的项目创建podspec文件</p>

<p>我们可以为自己的开源项目创建podspec文件，首先通过如下命令初始化一个podspec文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod spec create your_pod_spec_name</span></code></pre></td></tr></table></div></figure>


<p>该命令执行之后，CocoaPods会生成一个名为your_pod_spec_name.podspec的文件，然后我们修改其中的相关内容即可。</p>

<p>使用私有的pods</p>

<p>我们可以直接指定某一个依赖的podspec，这样就可以使用公司内部的私有库。该方案有利于使企业内部的公共项目支持CocoaPods。如下是一个示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod 'MyCommon', :podspec =&gt; 'https://heyandev.github.com/common/myCommon.podspec'</span></code></pre></td></tr></table></div></figure>


<p>不更新podspec</p>

<p>CocoaPods在执行pod install和pod update时，会默认先更新一次podspec索引。使用&ndash;no-repo-update参数可以禁止其做索引更新操作。如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod install --no-repo-update
</span><span class='line'>pod update --no-repo-update</span></code></pre></td></tr></table></div></figure>


<p>生成第三方库的帮助文档</p>

<p>如果你想让CococaPods帮你生成第三方库的帮助文档，并集成到Xcode中，那么用brew安装appledoc即可：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>brew install appledoc</span></code></pre></td></tr></table></div></figure>


<p>关于appledoc，它最大的优点是可以将帮助文档集成到Xcode中，这样你在敲代码的时候，按住opt键单击类名或方法名，就可以显示出相应的帮助文档。</p>

<p>原理</p>

<p>大概研究了一下CocoaPods的原理，它是将所有的依赖库都放到另一个名为Pods项目中，然后让主项目依赖Pods项目，这样，源码管理工作都从主项目移到了Pods项目中。发现的一些技术细节有：</p>

<p>Pods项目最终会编译成一个名为libPods.a的文件，主项目只需要依赖这个.a文件即可。
对于资源文件，CocoaPods提供了一个名为Pods-resources.sh的bash脚本，该脚本在每次项目编译的时候都会执行，将第三方库的各种资源文件复制到目标目录中。
CocoaPods通过一个名为Pods.xcconfig的文件来在编译时设置所有的依赖和参数。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Github上搭建Octopress博客]]></title>
    <link href="http://heyandev.github.io/blog/2015/01/29/zai-githubshang-da-jian-octopressbo-ke/"/>
    <updated>2015-01-29T13:21:50+08:00</updated>
    <id>http://heyandev.github.io/blog/2015/01/29/zai-githubshang-da-jian-octopressbo-ke</id>
    <content type="html"><![CDATA[<p>安装Octopress博客前需在本机上安装Ruby运行环境和Devkit，另外还要下载Octopress，更改gem的更新源，安装依赖项。本文将针对Github上的Octopress博客搭建进行详细说明。</p>

<!--more-->


<p>一、搭建本地环境</p>

<p>为了在Github上使用Octopress，需要首先配置一下本地环境：</p>

<p>首先安装Git，下载<a href="https://code.google.com/p/msysgit/downloads/list">msysgit</a>，目前最新版本是 <a href="http://msysgit.googlecode.com/files/Git-1.7.10-preview20120409.exe">Git-1.7.10-preview20120409.exe</a> ，安装可参考<a href="https://help.github.com/articles/set-up-git/">官方文档</a>。</p>

<p>然后安装Ruby， <a href="http://octopress.org/docs/setup/">Octopress 官方文档</a>中指定的 Ruby 版本是 1.9.2，所以我们选择 Ruby 1.9.2-p290，下载 <a href="http://rubyforge.org/frs/download.php/75127/rubyinstaller-1.9.2-p290.exe">rubyinstaller-1.9.2-p290.exe</a>，双击安装，安装时记得选中“Add Ruby executables to your PATH”。</p>

<p>为了检查ruby是否已加入到PATH中，可在 Windows 的cmd窗口中执行以下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ruby –version</span></code></pre></td></tr></table></div></figure>


<p>接着安装Devkit，选择下载 4.5.2 版本:<a href="https://github.com/downloads/oneclick/rubyinstaller/DevKit-tdm-32-4.5.2-20111229-1559-sfx.exe">DevKit-tdm-32-4.5.2-20111229-1559-sfx.exe</a>，下载完成后，将其解压到如 E:\DevKit，然后在win的cmd窗口中执行如下命令进行安装：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>E:
</span><span class='line'>cd DevKit
</span><span class='line'>ruby dk.rb init
</span><span class='line'>ruby dk.rb install</span></code></pre></td></tr></table></div></figure>


<p>最后安装python，主要是博客代码加亮模块需要python环境的支持，<a href="http://www.activestate.com/activepython/downloads">下载2.7版</a>，安装完以后，在Windows的cmd窗口中执行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>easy_install pygments</span></code></pre></td></tr></table></div></figure>


<p>本地环境配置结束。</p>

<p>二、更新本地环境配置
为了支持中文UTF-8编码，对Windows环境变量配置如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>LANG=zh_CN.UTF-8
</span><span class='line'>LC_ALL=zh_CN.UTF-8</span></code></pre></td></tr></table></div></figure>


<p>也可在直接在Windows的cmd窗口下运行命令</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>set LANG=zh_CN.UTF-8
</span><span class='line'>set LC_ALL=zh_CN.UTF-8</span></code></pre></td></tr></table></div></figure>


<p>更新gem的更新源，ruby的官方更新源经常被河蟹，换成国内的更新源，这样速度就快多了，变更如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gem sources -a http://ruby.taobao.org/
</span><span class='line'>gem sources -r http://rubygems.org/
</span><span class='line'>gem sources -l</span></code></pre></td></tr></table></div></figure>


<p>最后一个命令可查看更该后的更新源列表。</p>

<p>三、下载并配置Octopress
首先下载Octopress源码，可以使用下面git命令下载，也可直接在Octopress Github库中下载octopress的zip包<a href="https://nodeload.github.com/imathis/octopress/zipball/master">（点击下载）</a>，然后将下载的压缩包解压到E盘根目录，修改解压后的文件夹名称为 octopress。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>E:
</span><span class='line'>git clone git://github.com/imathis/octopress.git  octopress</span></code></pre></td></tr></table></div></figure>


<p>然后更新 Octopress 的gem更新源：进到 E:octopress 目录，用文本编辑器（例如记事本）打开文件Gemfile，将里面source &ldquo;<a href="http://rubygems.org/">http://rubygems.org/</a>&#8220;改为source &#8221;<a href="http://ruby.taobao.org/">http://ruby.taobao.org/</a>&#8220;。</p>

<p>最后安装Octopress的依赖项，在Windows的CMD窗口输入以下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>E:
</span><span class='line'>cd octopress
</span><span class='line'>gem install bundler
</span><span class='line'>bundle install</span></code></pre></td></tr></table></div></figure>


<p>四、新建Github Repositories
登录<a href="http://github.com">Github</a>，假设你的用户名是username，首先要新建一个命名为 username.github.com 的Repo，命名必须是这个格式，如果不这样命名的话，在运行命令 rake setup_github_pages  之后不能够自动创建后面提到的master和source 分支，而是作为普通仓库生成 gh-pages 分支。</p>

<p>五、发布Octopress到Github
1、打开Windows下的命令窗口，进入到Octopress所在的目录，输入命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake setup_github_pages</span></code></pre></td></tr></table></div></figure>


<p>按照提示输入刚才新建的Repo地址，类似：git@github.com:username/username.github.com或git@github.com:username/username.github.com.git。</p>

<p>2、接着输入命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake install
</span><span class='line'>rake generate
</span><span class='line'>rake preview</span></code></pre></td></tr></table></div></figure>


<p>其中rake install是安装Octopress默认主题的，rake gnerate是生成静态页面的，这两个命令是必须运行的，而rake preview则是用来本地浏览的（运行时看屏幕上提示，按Ctrl+C并输入Y来终止批处理操作），运行后打开浏览器，输入 <a href="http://localhost:4000/">http://localhost:4000/</a> 就可以看到界面了，不想预览的话也可以不运行，直接进入下一步。</p>

<p>3、将博客发布到Github上，输入下面命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake deploy</span></code></pre></td></tr></table></div></figure>


<p>这样，生成的内容将会自动发布到master分支，并且可以使用 <a href="http://username.github.com">http://username.github.com</a> 访问内容。</p>

<p>4、别忘了把所有源文件发布到 source 分支下面：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git add .
</span><span class='line'>git commit -m “your message”
</span><span class='line'>git push origin source</span></code></pre></td></tr></table></div></figure>


<p>至此，所有发布完成，接下来就是对博客的设置了。</p>

<p>六、Ocotpress博客配置
更改下面的配置后，还需要运行 rake generate、rake deploy等等命令的。</p>

<p>1、默认的博客运行成功的话，就需要按照自己的要求对博客配置进行修改了，主要是修改Octopress根目录下的主配置文件_config.yml。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>url:  http://username.github.com                 # 博客地址
</span><span class='line'>title:  蔓草札记                                            # 博客标题
</span><span class='line'>subtitle:  感受生活，感悟工作，感触心灵           # 副标题
</span><span class='line'>author:  xhhjin                                                       # 作者
</span><span class='line'>simple_search:  http://www.google.com.hk/search     # 搜索引擎
</span><span class='line'>description:                                                            # 关于博客的描述
</span><span class='line'>subscribe_rss:  /atom.xml                  # Rss订阅地址, 默认是  /atom.xml
</span><span class='line'>subscribe_email:                               # 提供Email订阅的地址
</span><span class='line'>email:                                              # Rss订阅的Email地址
</span><span class='line'>root:  /               # 博客路径，默认是“/“，如果你打算在子目录中，记得修改这个路径
</span><span class='line'>permalink: /blog/:year/:month/:day/:title/           # 文章的固定链接形式</span></code></pre></td></tr></table></div></figure>


<p>2、更换主题</p>

<p>主题位于 octopress/.theme 目录下，默认主题为 classic。 如果需要更改主题（可在网上查找），下载后将主题也放在.theme目录下即可，如果主题名字为blog_theme，那么安装主题时输入以下命令即可：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake install [‘blog_theme’]</span></code></pre></td></tr></table></div></figure>


<p>七、绑定域名
Github Pages绑定域名的方法有点特殊，需要在Octopress/source目录下建个无后缀的CNAME文本文件，文件内容就是你的域名，例如github.xuhehuan.com，然后修改A纪录到207.97.227.245 ，或者 CNAME 指向 username.github.com，下面就等着解析生效了</p>
]]></content>
  </entry>
  
</feed>
